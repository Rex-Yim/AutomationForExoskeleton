--- CONCATENATED CODE FROM PROJECT: AutomationForExoskeleton ---

### START OF FILE: startup.m
### FILE Path: AutomationForExoskeleton/startup.m
%% startup.m
% -------------------------------------------------------------------------
% PURPOSE: Initialize the AutomationForExoskeleton Project
% -------------------------------------------------------------------------

function startup()
    clc;
    fprintf('===========================================================\n');
    fprintf('   Initializing AutomationForExoskeleton Project Environment\n');
    fprintf('===========================================================\n');

    %% 1. Path Management
    % Get project root
    projectRoot = fileparts(mfilename('fullpath'));
    fprintf('Project Root: %s\n', projectRoot);
    
    % Define paths individually to avoid concatenation errors
    configPath  = fullfile(projectRoot, 'config');
    scriptsPath = fullfile(projectRoot, 'scripts');
    utilsPath   = fullfile(projectRoot, 'scripts', 'utils');
    testsPath   = fullfile(projectRoot, 'tests');
    srcPath     = fullfile(projectRoot, 'src');
    
    % Initialize list with standard folders
    pathsToAdd = {configPath; scriptsPath; utilsPath; testsPath};

    % Add 'src' and all its subfolders (if it exists)
    if exist(srcPath, 'dir')
        % genpath returns a single long string of paths separated by colons/semicolons
        % We add it as a single entry; addpath handles the delimiters.
        pathsToAdd{end+1, 1} = genpath(srcPath); 
    end

    fprintf('Setting up paths...\n');
    
    % Add paths safely
    for i = 1:length(pathsToAdd)
        p = pathsToAdd{i};
        if ~isempty(p)
            addpath(p);
        end
    end
    
    % (Optional) Save path so you don't have to run this every time
    % savepath; 

    fprintf('  [OK] Source, Config, and Script paths added.\n');

    %% 2. Environment Setup
    % Ensure 'results' folder exists
    resultsDir = fullfile(projectRoot, 'results');
    if ~exist(resultsDir, 'dir')
        mkdir(resultsDir);
        fprintf('  [OK] Created missing ''results'' directory.\n');
    end

    %% 3. Check Toolboxes
    fprintf('Checking dependencies...\n');
    requiredToolboxes = {
        'Statistics and Machine Learning Toolbox', 'fitcsvm';
        'Sensor Fusion and Tracking Toolbox',      'imufilter';
        'Signal Processing Toolbox',               'fft'
    };
    
    missingCount = 0;
    for k = 1:size(requiredToolboxes, 1)
        tbName = requiredToolboxes{k, 1};
        funcCheck = requiredToolboxes{k, 2};
        
        if isempty(which(funcCheck))
            fprintf('  [WARNING] Missing: %s (needed for %s)\n', tbName, funcCheck);
            missingCount = missingCount + 1;
        else
            fprintf('  [OK] Found: %s\n', tbName);
        end
    end

    %% 4. Sanity Check
    try
        cfg = ExoConfig();
        fprintf('  [OK] Configuration loaded (Fs=%d).\n', cfg.FS);
    catch
        fprintf('  [NOTE] ExoConfig not found or errored. (Normal if project is empty)\n');
    end

    fprintf('===========================================================\n');
    fprintf(' Initialization Complete.\n');
end
### END OF FILE: startup.m

### START OF FILE: ExoConfig.m
### FILE Path: AutomationForExoskeleton/config/ExoConfig.m
%% ExoConfig.m
% --------------------------------------------------------------------------
% CLASS: ExoConfig
% PURPOSE: Central configuration for parameters, constants, and paths.
% --------------------------------------------------------------------------
% LOCATION: config/ExoConfig.m
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-17
% --------------------------------------------------------------------------

classdef ExoConfig < handle
    properties (Constant)
        % ---------------- System Parameters ----------------
        FS = 100;               % Sampling Frequency (Hz)
        WINDOW_SIZE = 100;      % Sliding window size (1.0 second)
        STEP_SIZE = 50;         % Sliding window step (0.5 second)
        
        % ---------------- File Paths -----------------------
        % Uses relative paths from the project root
        FILE = struct(...
            'SVM_MODEL', fullfile('results', 'Binary_SVM_Model.mat'), ...
            'USCHAD_DATA', fullfile('data', 'public', 'USC-HAD', 'usc_had_dataset.mat') ...
        );
        
        % ---------------- Dataset Definitions --------------
        DS = struct(...
            'USCHAD', struct(...
                'WALKING_LABELS', [1, 2, 3, 4, 5, 6], ...
                'NON_WALKING_LABELS', [7, 8, 9, 10, 11, 12] ...
            )...
        );
        
        % ---------------- State Machine --------------------
        STATE_STANDING = 0;
        STATE_WALKING = 1;
        
        % ---------------- Simulation -----------------------
        ACTIVITY_SIMULATION = 'walking_straight';
    end
end
### END OF FILE: ExoConfig.m

### START OF FILE: LoadHuGaDB.m
### FILE Path: AutomationForExoskeleton/data/public/HuGaDB/LoadHuGaDB.m
%% LoadHuGaDB.m
% --------------------------------------------------------------------------
% FUNCTION: [] = LoadHuGaDB()
% PURPOSE: Loads all raw HuGaDB text files, parses the data, and saves it 
%          to a single .mat file, structured for use with the project's 
%          three-IMU (Back, HipL, HipR) pipeline convention.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-12
% LAST MODIFIED: 2025-12-14 (Restructured output for pipeline compatibility)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - dlmread (MATLAB built-in)
% --------------------------------------------------------------------------
% NOTES:
% - HuGaDB Sensor Mapping:
%   - Project's HipL -> HuGaDB Left Thigh (lt)
%   - Project's HipR -> HuGaDB Right Thigh (rt)
%   - Project's Back -> Dummy zeros (HuGaDB lacks a dedicated back sensor)
% --------------------------------------------------------------------------

clear; clc;

dataDir = 'HuGaDB_v2_raw'; % Path to .txt files
outputFile = 'hugadb_dataset.mat';

files = dir(fullfile(dataDir, '*.txt'));
hugadb_data = struct(); % Store all sessions

if isempty(files)
    error('No raw HuGaDB .txt files found in %s.', dataDir);
end

fprintf('Loading and restructuring %d HuGaDB trials...\n', length(files));

% Activity ID to Name mapping (simplified example for HuGaDB)
% Labels in HuGaDB are: 1=Sit, 2=Stand, 3=SitToStand, 4=StandToSit, 5=Walk, 6=StairsUp, 7=StairsDown, 8=Run
activityNames = {'Sit', 'Stand', 'SitToStand', 'StandToSit', 'Walk', 'StairsUp', 'StairsDown', 'Run'};

for i = 1:length(files)
    filePath = fullfile(dataDir, files(i).name);
    % Skips 4 header lines using dlmread
    rawMatrix = dlmread(filePath, '\t', 4, 0); 

    % --- 1. Parse Raw Data (Column indices based on standard HuGaDB format) ---
    
    % Data for Hip L (using Left Thigh IMU)
    data.hipL.acc = rawMatrix(:, 31:33); % Left thigh accel
    data.hipL.gyro = rawMatrix(:, 34:36); % Left thigh gyro

    % Data for Hip R (using Right Thigh IMU)
    data.hipR.acc = rawMatrix(:, 13:15); % Right thigh accel
    data.hipR.gyro = rawMatrix(:, 16:18); % Right thigh gyro

    % Data for Back (Dummy zero data to satisfy pipeline input)
    data.back.acc = zeros(size(data.hipL.acc));
    data.back.gyro = zeros(size(data.hipL.gyro));

    % Activity label and Metadata
    label = rawMatrix(:, 39); % Activity label
    data.label = label(1); % Use the first label as the trial label (assuming single activity per file)
    data.activityName = activityNames{data.label};
    data.fs = 100; % Assuming 100 Hz for HuGaDB (common rate)
    
    % Store the full label vector separately if needed for time-series analysis
    data.labels_full = label; 
    
    % --- 2. Store in Main Structure ---
    sessionID = files(i).name(1:end-4); % e.g., 'HuGaDB_v2_various_01_00'
    hugadb_data.(sessionID) = data;
end

save(outputFile, 'hugadb_data', '-v7.3');
fprintf('HuGaDB saved as %s (%d trials) with pipeline-compatible structure.\n', outputFile, length(files));
### END OF FILE: LoadHuGaDB.m

### START OF FILE: LoadUSCHAD.m
### FILE Path: AutomationForExoskeleton/data/public/USC-HAD/LoadUSCHAD.m
%% LoadUSCHAD.m
% --------------------------------------------------------------------------
% FUNCTION: usc = LoadUSCHAD(rawDir)
% PURPOSE: Loads all raw USC-HAD .mat files (recursively from subfolders),
%          normalizes the structure, and saves all trials into a single
%          usc_had_dataset.mat file.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-12
% LAST MODIFIED: 2025-12-16 (Fixed for sensor_readings, units, regex; extract subj from folder)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - MATLAB built-in functions (dir, load, regexp)
% --------------------------------------------------------------------------
% NOTES:
% - Extracts from 'sensor_readings' (Nx6: acc_xyz, gyro_xyz).
% - Converts units: acc g→m/s², gyro dps→rad/s.
% - Filenames: a<act>t<trial>.mat (no _); subj from folder.
% - Recursively searches subfolders (e.g., SubjectX/) for .mat files.
% - Call without arguments to use default path.
% --------------------------------------------------------------------------

function usc = LoadUSCHAD(rawDir)
    if nargin < 1
        rawDir = fullfile('USC-HAD_raw');
    end

    if ~isfolder(rawDir)
        error('USC-HAD raw folder not found: %s', rawDir);
    end

    % Recursive search for all .mat files in subfolders
    files = dir(fullfile(rawDir, '**/*.mat')); % '**' enables recursive search

    if isempty(files)
        error('No raw USC-HAD .mat files found in %s or its subfolders.', rawDir);
    end

    usc = struct();
    activityNames = {'WalkForward','WalkLeft','WalkRight','GoUpstairs',...
                     'GoDownstairs','RunForward','Jump','Sit','Stand',...
                     'Sleep','ElevatorUp','ElevatorDown'};

    fprintf('Loading %d USC-HAD trials...\n', length(files));
    skipped = 0;

    for i = 1:length(files)
        % Construct full filepath
        filepath = fullfile(files(i).folder, files(i).name);
        tmp = load(filepath);

        % --- Extract Sensor Data ---
        if isfield(tmp, 'sensor_readings')
            readings = tmp.sensor_readings;
            
            % Assume Nx6: columns 1-3 acc (g), 4-6 gyro (dps)
            % Check size and orient as Nx3
            if size(readings, 2) == 6  % Standard case
                acc = readings(:, 1:3);  % Nx3
                gyro = readings(:, 4:6); % Nx3
            elseif size(readings, 2) == 7  % If time column (col 1)
                acc = readings(:, 2:4);
                gyro = readings(:, 5:7);
            else
                warning('Skipping file %s: Unexpected sensor_readings size (%dx%d).', files(i).name, size(readings));
                skipped = skipped + 1;
                continue;
            end
            
            % If data is transposed (unlikely)
            if size(acc, 1) < size(acc, 2)
                acc = acc';
                gyro = gyro';
            end
            
            % Unit conversions
            acc = acc * 9.80665;      % g → m/s²
            gyro = deg2rad(gyro);     % dps → rad/s
        else
            warning('Skipping file %s: Missing ''sensor_readings'' field.', files(i).name);
            skipped = skipped + 1;
            continue;
        end

        % --- Parse Filename and Folder ---
        % Filename: a<act>t<trial>.mat (no underscores)
        tokens = regexp(files(i).name, 'a(?<act>\d+)t(?<trial>\d+)', 'names');
        if isempty(tokens)
            warning('Skipping invalid filename: %s', files(i).name);
            skipped = skipped + 1;
            continue;
        end

        % Extract subject from folder (e.g., 'Subject3' → subj=3)
        folder_tokens = regexp(files(i).folder, 'Subject(?<subj>\d+)', 'names');
        if isempty(folder_tokens)
            warning('Skipping file %s: Unable to parse subject from folder %s.', files(i).name, files(i).folder);
            skipped = skipped + 1;
            continue;
        end

        act = str2double(tokens.act);
        trial = str2double(tokens.trial);
        subj = str2double(folder_tokens.subj);

        usc_field = sprintf('s%s_a%s_t%s', num2str(subj), tokens.act, tokens.trial);

        % Store in usc struct
        usc.(usc_field).acc = acc;
        usc.(usc_field).gyro = gyro;
        usc.(usc_field).label = act;
        usc.(usc_field).activityName = activityNames{act};
        usc.(usc_field).fs = 100;  % USC-HAD is 100 Hz
    end

    outputFile = 'usc_had_dataset.mat';
    save(outputFile, 'usc', '-v7.3');
    fprintf('USC-HAD saved as %s (%d trials loaded, %d skipped).\n', outputFile, length(files) - skipped, skipped);
end
### END OF FILE: LoadUSCHAD.m

### START OF FILE: displayData_acc.m
### FILE Path: AutomationForExoskeleton/data/public/USC-HAD/displayData_acc.m
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Author: Mi Zhang
%Date: July, 2010
%File Name: displayData_acc.m
%Description: Visualize the 3-axis accelerometer data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Fs = 100;               % Sampling frequency = 100Hz

% Read the data
data = sensor_readings;
acc_x = data(: ,1);
acc_y = data(: ,2);
acc_z = data(: ,3);

% Parameter declaration
BIN_COUNT = 10;         % 
T = 1/Fs;               % 
Interval = 1000 / Fs;   %
L = size(acc_x, 1);     % 
t = (0:L-1)*T;          %

% Visualize the time series, histogram, and FFT
figure;
% Time series
subplot(3, 3, 1);
plot(t, acc_x);
grid on;
xlabel('Time (s)');
ylabel('Acceleration (g)');
title('X-Axis Data');

% Histogram
subplot(3, 3, 2);
hist(acc_x, BIN_COUNT);
grid on;
xlabel('Acceleration (g)');
ylabel('Count');
title('X-Axis Distribution');

% Spectral analysis
subplot(3, 3, 3);
NFFT = 2^nextpow2(L);               
Y = fft(acc_x, NFFT)/L;
f = Fs/2*linspace(0,1,NFFT/2+1);
plot(f,2*abs(Y(1:NFFT/2+1)));
title('X-Axis Spectrum');
xlabel('Frequency (Hz)');
ylabel('|X(f)|');

% Time series
subplot(3, 3, 4);
plot(t, acc_y);
grid on;
xlabel('Time (s)');
ylabel('Acceleration (g)');
title('Y-Axis Data');

% Histogram
subplot(3, 3, 5);
hist(acc_y, BIN_COUNT);
grid on;
xlabel('Acceleration (g)');
ylabel('Count');
title('Y-Axis Distribution');

% Spectral analysis
subplot(3, 3, 6);
NFFT = 2^nextpow2(L);              
Y = fft(acc_y, NFFT)/L;
f = Fs/2*linspace(0,1,NFFT/2+1);
plot(f,2*abs(Y(1:NFFT/2+1)));
title('Y-Axis Spectrum');
xlabel('Frequency (Hz)');
ylabel('|Y(f)|');

% Time series
subplot(3, 3, 7);
plot(t, acc_z);
grid on;
xlabel('Time (s)');
ylabel('Acceleration (g)');
title('Z-Axis Data');

% Histogram
subplot(3, 3, 8);
hist(acc_z, BIN_COUNT);
grid on;
xlabel('Acceleration (g)');
ylabel('Count');
title('Z-Axis Distribution');

% Spectral analysis
subplot(3, 3, 9);
NFFT = 2^nextpow2(L);               
Y = fft(acc_z, NFFT)/L;
f = Fs/2*linspace(0,1,NFFT/2+1);
plot(f,2*abs(Y(1:NFFT/2+1)));
title('Z-Axis Spectrum');
xlabel('Frequency (Hz)');
ylabel('|Z(f)|');



### END OF FILE: displayData_acc.m

### START OF FILE: displayData_gyro.m
### FILE Path: AutomationForExoskeleton/data/public/USC-HAD/displayData_gyro.m
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Author: Mi Zhang
%Date: July, 2010
%File Name: displayData_gyro.m
%Description: Visualize the 3-axis gyroscope data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Fs = 100;               % Sampling frequency = 100Hz

% Read the data
data = sensor_readings;
gyro_x = data(: ,4);
gyro_y = data(: ,5);
gyro_z = data(: ,6);

% Parameter declaration
BIN_COUNT = 10;         % 
T = 1/Fs;               % 
Interval = 1000 / Fs;   %
L = size(acc_x, 1);     % 
t = (0:L-1)*T;          %

% Visualize the time series, histogram, and FFT
figure;
% Time series
subplot(3, 3, 1);
plot(t, gyro_x);
grid on;
xlabel('Time (s)');
ylabel('Gyro (dps)');
title('X-Axis Gyro Data');

% Histogram
subplot(3, 3, 2);
hist(gyro_x, BIN_COUNT);
grid on;
xlabel('Gyro (dps)');
ylabel('Count');
title('X-Axis Gyro Distribution');

% Spectral analysis
subplot(3, 3, 3);
NFFT = 2^nextpow2(L);               
Y = fft(gyro_x, NFFT)/L;
f = Fs/2*linspace(0,1,NFFT/2+1);
plot(f,2*abs(Y(1:NFFT/2+1)));
title('X-Axis Gyro Spectrum');
xlabel('Frequency (Hz)');
ylabel('|Y(f)|');

% Time series
subplot(3, 3, 4);
plot(t, gyro_y);
grid on;
xlabel('Time (s)');
ylabel('Gyro (dps)');
title('Y-Axis Gyro Data');

% Histogram
subplot(3, 3, 5);
hist(gyro_y, BIN_COUNT);
grid on;
xlabel('Gyro (dps)');
ylabel('Count');
title('Y-Axis Gyro Distribution');

% Spectral analysis
subplot(3, 3, 6);
NFFT = 2^nextpow2(L);              
Y = fft(gyro_y, NFFT)/L;
f = Fs/2*linspace(0,1,NFFT/2+1);
plot(f,2*abs(Y(1:NFFT/2+1)));
title('Y-Axis Gyro Spectrum');
xlabel('Frequency (Hz)');
ylabel('|Y(f)|');

% Time series
subplot(3, 3, 7);
plot(t, gyro_z);
grid on;
xlabel('Time (s)');
ylabel('Gyro (dps)');
title('Z-Axis Gyro Data');

% Histogram
subplot(3, 3, 8);
hist(gyro_z, BIN_COUNT);
grid on;
xlabel('Gyro (dps)');
ylabel('Count');
title('Z-Axis Gyro Distribution');

% Spectral analysis
subplot(3, 3, 9);
NFFT = 2^nextpow2(L);               
Y = fft(gyro_z, NFFT)/L;
f = Fs/2*linspace(0,1,NFFT/2+1);
plot(f,2*abs(Y(1:NFFT/2+1)));
title('Z-Axis Gyro Spectrum');
xlabel('Frequency (Hz)');
ylabel('|Y(f)|');



### END OF FILE: displayData_gyro.m

### START OF FILE: RunExoskeletonPipeline.m
### FILE Path: AutomationForExoskeleton/scripts/RunExoskeletonPipeline.m
%% RunExoskeletonPipeline.m
% --------------------------------------------------------------------------
% FUNCTION: [] = RunExoskeletonPipeline()
% PURPOSE: Main script to simulate the real-time exoskeleton control system. 
% It integrates Data Acquisition, Sensor Fusion (Kalman), 
% and Locomotion Classification (SVM/FSM) to generate control commands.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-17 (Fixed Pathing and Static Method Calls)
% --------------------------------------------------------------------------

clc; clear; close all;

% --- Path Setup ---
% Get the location of this script to anchor paths
scriptPath = fileparts(mfilename('fullpath')); 
% Assuming script is in /scripts/, go up one level to Project Root
projectRoot = fileparts(scriptPath); 

% --- Configuration ---
cfg = ExoConfig();
ACTIVITY_NAME = cfg.ACTIVITY_SIMULATION;
FS = cfg.FS; 
WINDOW_SIZE = cfg.WINDOW_SIZE; 
STEP_SIZE = cfg.STEP_SIZE; 

% --- 1. Load Trained Model ---
% Construct absolute path to ensure file is found regardless of CWD
model_path = fullfile(projectRoot, cfg.FILE.SVM_MODEL);

if ~exist(model_path, 'file')
    error('Trained SVM Model not found at: %s\nPlease run TrainSvmBinary first.', model_path);
end
loaded = load(model_path, 'SVMModel');
SVMModel = loaded.SVMModel;
fprintf('Trained SVM Model loaded successfully.\n');

% --- 2. Initialize Exoskeleton State ---
current_fsm_state = cfg.STATE_STANDING;
hip_flexion_angles = zeros(1, 1); 

% --- 3. Initialize Sensor Fusion Filter (Kalman) ---
% FIX: Call static method via ClassName.MethodName
[fuse_back, fuse_hipL] = FusionKalman.initializeFilters(FS);

% --- 4. Load Data ---
% FIX: ImportData relies on relative paths ('../data'). We temporarily 
% switch to the 'scripts' folder to ensure the relative path resolves correctly.
currentDir = pwd;
cd(scriptPath); 
try
    [back, hipL, ~, annotations] = ImportData(ACTIVITY_NAME);
catch ME
    cd(currentDir); % Ensure we return to original dir even on error
    warning('Data import failed: %s. Using dummy data.', ME.message);
    % Fallback dummy data
    data_len = 5000;
    back.acc = [zeros(data_len, 2), ones(data_len, 1)*9.8];
    back.gyro = zeros(data_len, 3);
    hipL = struct('acc', zeros(data_len, 3), 'gyro', zeros(data_len, 3));
    annotations = table(zeros(data_len, 1), 'VariableNames', {'Label'});
end
cd(currentDir); % Restore path

n_total_samples = size(back.acc, 1);
hip_flexion_angles = zeros(n_total_samples, 1); % Pre-allocate
fsm_plot = zeros(n_total_samples, 1);
last_command = 0;

fprintf('Starting real-time simulation on %d samples...\n', n_total_samples);

% --- 5. Main Real-Time Simulation Loop ---
for i = 1:n_total_samples

    % --- Sensor Fusion ---
    % Standard imufilter usage: q = fuse(acc, gyro)
    q_back = fuse_back(back.acc(i,:), back.gyro(i,:));
    q_hipL = fuse_hipL(hipL.acc(i,:), hipL.gyro(i,:));
    
    % FIX: Call static method via ClassName.MethodName
    hip_flexion_angles(i) = FusionKalman.estimateAngle(q_back, q_hipL);

    % --- Locomotion Classification ---
    if mod(i - 1, STEP_SIZE) == 0 && (i + WINDOW_SIZE - 1) <= n_total_samples
        windowAcc = back.acc(i : i+WINDOW_SIZE-1, :);
        windowGyro = back.gyro(i : i+WINDOW_SIZE-1, :);

        features_vec = Features(windowAcc, windowGyro, FS);
        new_label = predict(SVMModel, features_vec);
        [exoskeleton_command, current_fsm_state] = RealtimeFsm(new_label, current_fsm_state);
        
        last_command = exoskeleton_command;
    end
    fsm_plot(i) = last_command;
end

fprintf('\nPipeline simulation complete.\n');

% --- 6. Visualization ---
figure('Name', 'Pipeline Output');
t = (1:n_total_samples) / FS;

subplot(3,1,1);
plot(t, hip_flexion_angles, 'LineWidth', 1.5);
title('Estimated Left Hip Flexion Angle (Kalman)');
ylabel('Angle (deg)'); grid on;

subplot(3,1,2);
stairs(t, fsm_plot, 'LineWidth', 1.5);
ylim([-0.1 1.1]);
title('Exoskeleton Control Command');
ylabel('Command (0=Stand, 1=Walk)'); grid on;

subplot(3,1,3);
if ismember('Label', annotations.Properties.VariableNames)
    plot(t, annotations.Label, 'k', 'LineWidth', 1.5);
    title('Ground Truth');
end

% Save results using absolute path
resultsFile = fullfile(projectRoot, 'results', 'realtime_pipeline_output.png');
saveas(gcf, resultsFile);
fprintf('Plot saved to: %s\n', resultsFile);
### END OF FILE: RunExoskeletonPipeline.m

### START OF FILE: TestPipelinePerformance.m
### FILE Path: AutomationForExoskeleton/scripts/TestPipelinePerformance.m
%% TestPipelinePerformance.m
% --------------------------------------------------------------------------
% FUNCTION: [metrics] = TestPipelinePerformance()
% PURPOSE: Runs the full real-time simulation pipeline and evaluates the 
% locomotion classification performance against ground truth labels.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Fixed ground truth binarization and missing gyro data)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - ExoConfig.m
% - ImportData.m
% - Features.m
% - RealtimeFsm.m
% - FusionKalman.m
% - Binary_SVM_Model.mat (Trained model)
% --------------------------------------------------------------------------
% NOTES:
% - Loads ground truth from Annotation.csv for the simulated activity.
% - Calculates Accuracy, Precision (Positive Predictive Value), and Recall (Sensitivity).
% --------------------------------------------------------------------------

function [metrics] = TestPipelinePerformance()

clc; close all;
cfg = ExoConfig();

% --- 0. Pre-Flight Check ---
model_path = cfg.FILE.SVM_MODEL;
if ~exist(model_path, 'file')
error('Trained SVM Model not found. Please run TrainSvmBinary first.');
end

% --- 1. Load Trained Model and Configuration ---
% Need to load ModelMetadata to ensure compatibility, even if not fully used here
loaded = load(model_path, 'SVMModel', 'ModelMetadata');
SVMModel = loaded.SVMModel;
ModelMetadata = loaded.ModelMetadata;

FS = ModelMetadata.fs;
WINDOW_SIZE = ModelMetadata.windowSize;
STEP_SIZE = ModelMetadata.stepSize;
ACTIVITY_NAME = cfg.ACTIVITY_SIMULATION;

fprintf('--- Starting Full Pipeline Performance Test ---\n');
fprintf('Simulating Activity: %s (FS: %d Hz)\n', ACTIVITY_NAME, FS);

% --- 2. Load Data and Ground Truth ---
try
[back, hipL, ~, annotations] = ImportData(ACTIVITY_NAME); 
n_total_samples = size(back.acc, 1);

if ~ismember('Label', annotations.Properties.VariableNames) || size(annotations, 1) ~= n_total_samples
error('Annotation file is invalid or size mismatch. Cannot perform evaluation.');
end

ground_truth = annotations.Label; % Multi-class label (e.g., 1, 4, 8)

% Fix: Binarize the ground truth label to match the FSM output (0 or 1)
walking_labels = cfg.DS.USCHAD.WALKING_LABELS; 
non_walking_labels = cfg.DS.USCHAD.NON_WALKING_LABELS; 

ground_truth_binary = zeros(size(ground_truth));
% Map locomotion labels to 1 (WALKING)
ground_truth_binary(ismember(ground_truth, walking_labels)) = cfg.STATE_WALKING; 
% Map non-locomotion labels to 0 (STANDING)
ground_truth_binary(ismember(ground_truth, non_walking_labels)) = cfg.STATE_STANDING; 

catch ME
error('Data loading or ground truth check failed: %s', ME.message);
end

% --- 3. Run Simulation (Simplified Pipeline Loop) ---

% Initialize states and filters
current_fsm_state = cfg.STATE_STANDING; 
fsm_plot = zeros(n_total_samples, 1);
last_command = 0;
% Filters are initialized in RunExoskeletonPipeline, but we initialize here too
[fuse_back, fuse_hipL] = initializeFilters(FS); 

for i = 1:n_total_samples

% Kinematics (Run but results discarded here, focus is on classification)
update(fuse_back, back.acc(i,:), back.gyro(i,:));
update(fuse_hipL, hipL.acc(i,:), hipL.gyro(i,:)); 

% Classification Check
if mod(i - 1, STEP_SIZE) == 0 && (i + WINDOW_SIZE - 1) <= n_total_samples

windowAcc = back.acc(i : i+WINDOW_SIZE-1, :);
windowGyro = back.gyro(i : i+WINDOW_SIZE-1, :); % Fix: Extract Gyro window

% Fix: Pass both Accel and Gyro to Features.m
features_vec = Features(windowAcc, windowGyro, FS); 
new_label = predict(SVMModel, features_vec); 

[exoskeleton_command, current_fsm_state] = RealtimeFsm(new_label, current_fsm_state);
last_command = exoskeleton_command; 
end

fsm_plot(i) = last_command;
end

% --- 4. Performance Evaluation ---

% We compare the FSM output (fsm_plot) against the binarized ground truth.
% True Positives (TP): Walk predicted as Walk
% Fix: Use ground_truth_binary instead of raw ground_truth
TP = sum(ground_truth_binary == 1 & fsm_plot == 1);
% True Negatives (TN): Stand predicted as Stand
TN = sum(ground_truth_binary == 0 & fsm_plot == 0);
% False Positives (FP): Stand predicted as Walk (Type I Error)
FP = sum(ground_truth_binary == 0 & fsm_plot == 1);
% False Negatives (FN): Walk predicted as Stand (Type II Error)
FN = sum(ground_truth_binary == 1 & fsm_plot == 0);

% Calculate Metrics
Accuracy = (TP + TN) / (TP + TN + FP + FN);
Precision = TP / (TP + FP); % How many predicted 'Walks' were correct
Recall = TP / (TP + FN); % How many actual 'Walks' were caught
Specificity = TN / (TN + FP); % How many actual 'Stands' were caught

metrics.TP = TP;
metrics.TN = TN;
metrics.FP = FP;
metrics.FN = FN;
metrics.Accuracy = Accuracy;
metrics.Precision = Precision;
metrics.Recall = Recall;
metrics.Specificity = Specificity;


% --- 5. Report Results ---
fprintf('\n--- Classification Performance Summary ---\n');
fprintf('Target Activity: %s\n', ACTIVITY_NAME);
fprintf('Total Samples: %d\n', n_total_samples);
fprintf('------------------------------------------\n');
fprintf('True Positives (TP): %d\n', TP);
fprintf('True Negatives (TN): %d\n', TN);
fprintf('False Positives (FP): %d\n', FP);
fprintf('False Negatives (FN): %d\n', FN);
fprintf('------------------------------------------\n');
fprintf('SYSTEM ACCURACY: %.2f%%\n', Accuracy * 100);
fprintf('PRECISION (Walk): %.2f%%\n', Precision * 100);
fprintf('RECALL (Walk): %.2f%%\n', Recall * 100);
fprintf('SPECIFICITY (Stand): %.2f%%\n', Specificity * 100);
fprintf('------------------------------------------\n');

end
### END OF FILE: TestPipelinePerformance.m

### START OF FILE: TrainSvmBinary.m
### FILE Path: AutomationForExoskeleton/scripts/TrainSvmBinary.m
%% TrainSvmBinary.m
% --------------------------------------------------------------------------
% SCRIPT: TrainSvmBinary
% PURPOSE: Trains the binary SVM (Walking vs. Standing) and saves the model.
% --------------------------------------------------------------------------
% LOCATION: scripts/TrainSvmBinary.m
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-17
% --------------------------------------------------------------------------

clc; clear; close all;

% Initialize Configuration
cfg = ExoConfig();

fprintf('===========================================================\n');
fprintf('   Training SVM Binary Classifier (Walk vs. Stand)\n');
fprintf('===========================================================\n');

% --- 1. Prepare Data ---
try
    % This function now handles all loading, windowing, and feature extraction
    [featuresAll, labelsAll, ModelMetadata] = PrepareTrainingData(cfg);
catch ME
    error('Data preparation failed: %s', ME.message);
end

if isempty(featuresAll)
    error('No features extracted. Ensure "LoadUSCHAD" has been run and data is valid.');
end

% --- 2. Train SVM Model ---
fprintf('\nTraining SVM (RBF Kernel, Standardized)...\n');

% Fit binary SVM
% - Kernel: RBF (Gaussian) is typically best for non-linear IMU boundaries
% - Standardize: Critical because features (Acc vs Gyro) have different scales
SVMModel = fitcsvm(featuresAll, labelsAll, ...
    'KernelFunction', 'rbf', ...
    'Standardize', true, ...
    'BoxConstraint', 1.0, ...
    'ClassNames', [0, 1]);

% --- 3. Evaluate Performance (Cross-Validation) ---
fprintf('Performing 5-Fold Cross-Validation...\n');
cvModel = crossval(SVMModel, 'KFold', 5);
cvError = kfoldLoss(cvModel);
cvAccuracy = (1 - cvError) * 100;

fprintf('-----------------------------------------------------------\n');
fprintf('   Model Accuracy (5-Fold CV): %.2f%%\n', cvAccuracy);
fprintf('-----------------------------------------------------------\n');

% --- 4. Save Model ---
savePath = cfg.FILE.SVM_MODEL;

% Ensure results directory exists
[saveDir, ~] = fileparts(savePath);
if ~exist(saveDir, 'dir')
    mkdir(saveDir);
end

% Save both the Model object and the Metadata
save(savePath, 'SVMModel', 'ModelMetadata');
fprintf('Model saved successfully to:\n  -> %s\n', savePath);
fprintf('===========================================================\n');
### END OF FILE: TrainSvmBinary.m

### START OF FILE: ConcatenateCode.m
### FILE Path: AutomationForExoskeleton/scripts/utils/ConcatenateCode.m
%% ConcatenateCode.m
% --------------------------------------------------------------------------
% FUNCTION: [] = ConcatenateCode()
% PURPOSE: Generates a single, structured file (concatenated_code.txt) 
%          containing the source code of the entire project.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-12
% LAST MODIFIED: 2025-12-15 (Fixed path logic to be location-independent)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
%   - MATLAB built-in file I/O and utility functions (mfilename, fileparts, fullfile, mkdir).
% --------------------------------------------------------------------------
% NOTES:
%   - This version automatically determines the project root by locating the 
%     'scripts/utils' folder (where this script resides) and navigating two 
%     levels up.
%   - The script will work correctly no matter where it is called from, as 
%     long as it remains in 'scripts/utils/'.
%   - Uses '###' headers for visibility and structure.
%   - Output is saved to: [Project Root]/scripts/utils/concatenated_code.txt
% --------------------------------------------------------------------------

% --- Define Paths (Location-Independent Logic) ---

% 1. Get the full path to the currently running script (ConcatenateCode.m)
this_script_path = mfilename('fullpath');
if isempty(this_script_path)
    error('Could not determine script path. Ensure it is saved and on the MATLAB path.');
end

% 2. Determine the project root by traversing up two levels from the script's folder:
%    /scripts/utils/ConcatenateCode.m -> /scripts/utils/ -> /scripts/ -> /AutomationForExoskeleton/
output_dir = fileparts(this_script_path);    % Gets the /scripts/utils/ folder (where output is saved)
scripts_dir = fileparts(output_dir);         % Gets the /scripts/ folder
search_root = fileparts(scripts_dir);        % Gets the /AutomationForExoskeleton/ folder (the project root)

% 3. Extract the project name from the root folder
[~, project_name, ~] = fileparts(search_root);
project_name = strrep(project_name, filesep, '');

% 4. Define the output file path (output_dir is already /scripts/utils/)
output_filename = 'concatenated_code.txt';
output_full_path = fullfile(output_dir, output_filename);

% Ensure the output directory exists
if ~exist(output_dir, 'dir')
    mkdir(output_dir);
end
% --------------------------------------------------

fprintf('Starting code concatenation for copying...\n');

% 1. Find all .m files recursively and filter hidden folders
search_path = fullfile(search_root, '**', '*.m');
listing = dir(search_path);

files_to_concatenate = [];
for i = 1:length(listing)
    full_path = fullfile(listing(i).folder, listing(i).name);
    
    % Get the path relative to the true project root
    rel_path = extractAfter(full_path, search_root);
    if startsWith(rel_path, filesep)
        rel_path = extractAfter(rel_path, filesep);
    end
    
    % Check if any part of the path starts with a '.' (e.g., .git/...)
    parts = strsplit(rel_path, filesep);
    if ~any(startsWith(parts, '.'))
        files_to_concatenate = [files_to_concatenate; listing(i)];
    end
end

if isempty(files_to_concatenate)
    fprintf('No .m files found in visible project directories.\n');
    return;
end

% --- CUSTOM SORTING: Ensure correct file order (Root files first, then subfolders by path) ---
files_to_sort = files_to_concatenate; 
% 1. Calculate the relative path for every file
relative_paths = cell(length(files_to_sort), 1);
for i = 1:length(files_to_sort)
    full_path_abs = fullfile(files_to_sort(i).folder, files_to_sort(i).name);
    
    % Get the path relative to the true project root for sorting
    rel_path = extractAfter(full_path_abs, search_root);
    if startsWith(rel_path, filesep)
        rel_path = extractAfter(rel_path, filesep);
    end
    
    % Add a special prefix to root files to force them to sort first
    if isempty(fileparts(rel_path))
        relative_paths{i} = ['!', rel_path]; 
    else
        relative_paths{i} = rel_path;
    end
end
% 2. Sort the files based on the relative path strings
[~, idx] = sort(relative_paths);
files_to_concatenate = files_to_sort(idx);
% --------------------------------------------------------------------------------------------

% 2. Open the output file for writing (will overwrite if it exists)
fileID = fopen(output_full_path, 'wt', 'n', 'UTF-8');
if fileID == -1
    error('Could not open file for writing: %s', output_full_path);
end

% 3. Process and print/write each file
fprintf('\n--- CONCATENATED CODE START ---\n\n');

% Write the global header to the file (only to file)
fprintf(fileID, '--- CONCATENATED CODE FROM PROJECT: %s ---\n\n', project_name);

for i = 1:length(files_to_concatenate)
    file_info = files_to_concatenate(i);
    
    full_path_abs = fullfile(file_info.folder, file_info.name);
    
    % Construct the desired 'FILE Path' using the dynamic project name and relative segment
    rel_path_segment = extractAfter(full_path_abs, search_root);
    if startsWith(rel_path_segment, filesep)
        rel_path_segment = extractAfter(rel_path_segment, filesep);
    end
    
    % The output path format is now: ProjectName/relative/path/to/file.m
    file_path_output = sprintf('%s/%s', project_name, rel_path_segment);
    
    % Read the content of the file
    file_content = fileread(full_path_abs);
    
    % --- Generate Custom Structured Header (USING 3 HASH SIGNS) ---
    header_start_line1 = sprintf('### START OF FILE: %s\n', file_info.name);
    header_start_line2 = sprintf('### FILE Path: %s\n', file_path_output);
    header_end = sprintf('### END OF FILE: %s\n\n', file_info.name);
    
    % Print structured output to Command Window
    fprintf(header_start_line1);
    fprintf(header_start_line2);
    fprintf('%s\n', file_content); 
    fprintf(header_end);
    
    % Write structured output to the text file
    fprintf(fileID, header_start_line1);
    fprintf(fileID, header_start_line2);
    fprintf(fileID, '%s\n', file_content);
    fprintf(fileID, header_end);
end

% 4. Close the file and finalize output
fclose(fileID);

fprintf('\n--- CONCATENATED CODE END ---\n');
fprintf('Content printed to terminal for immediate copy/paste.\n');
fprintf('A consolidated version has also been saved to: %s\n', output_full_path);
### END OF FILE: ConcatenateCode.m

### START OF FILE: GenerateProjectTree.m
### FILE Path: AutomationForExoskeleton/scripts/utils/GenerateProjectTree.m
%% GenerateProjectTree.m
% --------------------------------------------------------------------------
% FUNCTION: GenerateProjectTree()
% PURPOSE : Generates a readable project directory tree and saves it to
%           scripts/utils/project_tree.txt
% FEATURES:
%   - Automatically finds project root regardless of current directory
%   - Shows first 3 items in folders with >10 contents
%   - Truncates large folders with "... (truncated: X more items)"
%   - Clean, properly aligned tree visualization
%   - Excludes hidden files/folders
% --------------------------------------------------------------------------
% AUTHOR     : Your Name
% CREATED    : 2025-12-12
% LAST UPDATE: 2025-12-16 (Fixed ternary operators, improved alignment)
% --------------------------------------------------------------------------

function GenerateProjectTree()

    % --- Determine paths (location-independent) ---
    this_script_path = mfilename('fullpath');
    if isempty(this_script_path)
        error('Cannot determine script path. Save the file and add to MATLAB path.');
    end

    utils_dir    = fileparts(this_script_path);           % scripts/utils/
    scripts_dir  = fileparts(utils_dir);                  % scripts/
    project_root = fileparts(scripts_dir);                % AutomationForExoskeleton/

    output_file  = fullfile(utils_dir, 'project_tree.txt');

    % --- Clean previous output ---
    if exist(output_file, 'file')
        delete(output_file);
    end

    fprintf('Starting project structure generation...\n');

    % --- Start capturing output to file ---
    diary(output_file);
    try
        [~, root_name] = fileparts(project_root);
        fprintf('%s/\n', root_name);

        drawTree(project_root, '');

    catch ME
        diary off;
        warning('Error during tree generation: %s', ME.message);
        rethrow(ME);
    end
    diary off;

    fprintf('Scan completed and saved to %s.\n', output_file);
end

%% --- Recursive Tree Drawing Function ---
function drawTree(current_path, prefix)

    % Get and filter directory contents
    listing = dir(current_path);
    is_valid = ~ismember({listing.name}, {'.', '..'});
    listing  = listing(is_valid);
    is_hidden = startsWith({listing.name}, '.');
    listing  = listing(~is_hidden);

    if isempty(listing)
        return;
    end

    % Separate and sort folders/files (case-insensitive)
    folders = listing([listing.isdir]);
    files   = listing(~[listing.isdir]);

    [~, idx_f] = sort(lower({folders.name}));
    [~, idx_i] = sort(lower({files.name}));

    folders = folders(idx_f);
    files   = files(idx_i);

    all_entries = [folders; files];
    N = length(all_entries);

    % Process each entry
    for i = 1:N
        entry   = all_entries(i);
        is_last = (i == N);

        % Determine connector and next prefix
        if is_last
            connector           = '└── ';
            next_prefix_segment = '    ';  % 4 spaces for alignment
        else
            connector           = '├── ';
            next_prefix_segment = '│   ';  % │ + 3 spaces
        end

        % Print current item
        name = entry.name;
        if entry.isdir
            name = [name, '/'];
        end
        fprintf('%s%s%s\n', prefix, connector, name);

        % If it's a folder, expand partially or fully
        if entry.isdir
            new_path   = fullfile(current_path, entry.name);
            new_prefix = [prefix, next_prefix_segment];

            % Count visible contents
            sub_list   = dir(new_path);
            sub_valid  = ~ismember({sub_list.name}, {'.', '..'});
            sub_hidden = startsWith({sub_list.name}, '.');
            sub_count  = sum(sub_valid & ~sub_hidden);

            if sub_count > 10
                % --- Show only first 3 items + truncation ---
                sub_entries = sub_list(sub_valid & ~sub_hidden);

                sub_folders = sub_entries([sub_entries.isdir]);
                sub_files   = sub_entries(~[sub_entries.isdir]);

                [~, sf_idx]  = sort(lower({sub_folders.name}));
                [~, sfi_idx] = sort(lower({sub_files.name}));

                sub_sorted = [sub_folders(sf_idx); sub_files(sfi_idx)];
                num_show   = min(3, length(sub_sorted));

                for k = 1:num_show
                    sub_entry = sub_sorted(k);
                    sub_name  = sub_entry.name;
                    if sub_entry.isdir
                        sub_name = [sub_name, '/'];
                    end

                    if k == num_show
                        sub_conn = '└── ';
                    else
                        sub_conn = '├── ';
                    end

                    fprintf('%s%s%s\n', new_prefix, sub_conn, sub_name);
                end

                remaining = sub_count - 3;
                if remaining > 0
                    fprintf('%s└── ... (truncated: %d more items)\n', new_prefix, remaining);
                end

            else
                % --- Show all contents (≤10 items) ---
                drawTree(new_path, new_prefix);
            end
        end
    end
end
### END OF FILE: GenerateProjectTree.m

### START OF FILE: ImportData.m
### FILE Path: AutomationForExoskeleton/src/acquisition/ImportData.m
%% ImportData.m
% --------------------------------------------------------------------------
% FUNCTION: [back, hipL, hipR, annotations] = ImportData(activityName)
% PURPOSE: Implements the Data Acquisition Protocol, reading raw CSV data from 
% a specified activity folder. Handles Timestamp column stripping.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-11
% LAST MODIFIED: 2025-12-17 (Added column cleaning in process_imu_table)
% --------------------------------------------------------------------------

function [back, hipL, hipR, annotations] = ImportData(activityName)
    % Define path to the specific activity folder relative to 'scripts'
    baseDir = '../data/raw/';
    activityPath = fullfile(baseDir, activityName);
    
    % Filenames
    fileAcc = fullfile(activityPath, 'Accelerometer.csv');
    fileGyro = fullfile(activityPath, 'Gyroscope.csv');
    fileAnnot = fullfile(activityPath, 'Annotation.csv');
    
    % Check files exist
    if ~isfolder(activityPath)
        error('Activity folder not found: %s', activityPath);
    end
    if ~isfile(fileAcc) || ~isfile(fileGyro)
        error('IMU data files not found in: %s', activityPath);
    end
    
    % --- 1. Import Raw Tables ---
    opts = detectImportOptions(fileAcc);
    accTable = readtable(fileAcc, opts);
    
    opts = detectImportOptions(fileGyro);
    gyroTable = readtable(fileGyro, opts);
    
    if isfile(fileAnnot)
        opts = detectImportOptions(fileAnnot);
        annotations = readtable(fileAnnot, opts);
    else
        warning('Annotation file not found. Returning empty table.');
        annotations = table();
    end
    
    % --- 2. Process and Assign Data ---
    back = process_imu_table(accTable, gyroTable);
    
    % Setup dummy data for hips (since we only have one physical sensor in this dataset)
    N_samples = size(back.acc, 1);
    
    hipL.acc = zeros(N_samples, 3);
    hipL.gyro = zeros(N_samples, 3);
    hipR.acc = zeros(N_samples, 3);
    hipR.gyro = zeros(N_samples, 3);
    
    fprintf('Imported %d samples of IMU data for activity "%s".\n', N_samples, activityName);
end

%% --- NESTED FUNCTION (Utility for Table Processing) ---
function imu = process_imu_table(accTable, gyroTable)
    % Converts tables to standard IMU data structure (Nx3 arrays).
    % Automatically keeps only the last 3 columns if Timestamp is present.

    rawAcc = table2array(accTable);
    rawGyro = table2array(gyroTable);

    % --- Fix: Handle Timestamp Column (e.g., if data is Nx4) ---
    if size(rawAcc, 2) > 3
        % Assume format is [Timestamp, X, Y, Z], take last 3
        imu.acc = rawAcc(:, end-2:end);
    else
        imu.acc = rawAcc;
    end

    if size(rawGyro, 2) > 3
        % Assume format is [Timestamp, X, Y, Z], take last 3
        imu.gyro = rawGyro(:, end-2:end);
    else
        imu.gyro = rawGyro;
    end
end
### END OF FILE: ImportData.m

### START OF FILE: PrepareTrainingData.m
### FILE Path: AutomationForExoskeleton/src/acquisition/PrepareTrainingData.m
%% PrepareTrainingData.m
% --------------------------------------------------------------------------
% FUNCTION: [features, labels_binary, ModelMetadata] = PrepareTrainingData(cfg)
% PURPOSE: Iterates through the USC-HAD dataset, extracts features using
%          the standardized pipeline logic, and binarizes labels.
% --------------------------------------------------------------------------
% LOCATION: src/acquisition/PrepareTrainingData.m
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-17
% --------------------------------------------------------------------------

function [features, labels_binary, ModelMetadata] = PrepareTrainingData(cfg)

    if nargin < 1
        cfg = ExoConfig();
    end

    % --- 1. Load USC-HAD Data Structure ---
    % Checks if the dataset exists. If not, prompts user to run LoadUSCHAD.
    if ~exist(cfg.FILE.USCHAD_DATA, 'file')
        error('USC-HAD dataset not found at: %s. \nPlease run "LoadUSCHAD" first.', cfg.FILE.USCHAD_DATA);
    end
    
    loadedData = load(cfg.FILE.USCHAD_DATA, 'usc');
    usc = loadedData.usc;

    features = [];
    labels_binary = [];
    all_trial_names = fieldnames(usc);

    fprintf('Preparing Training Data: Extracting features from %d trials...\n', length(all_trial_names));

    % --- 2. Iterate through all trials ---
    for i = 1:length(all_trial_names)
        trial_name = all_trial_names{i};
        trial = usc.(trial_name);
        
        % Data Access
        acc = trial.acc;
        gyro = trial.gyro;
        raw_label = trial.label;
        n_samples = size(acc, 1);
        
        % Skip trials shorter than one window
        if n_samples < cfg.WINDOW_SIZE
            continue; 
        end
        
        % --- Label Binarization ---
        % Convert specific USC-HAD Activity ID to Binary (1=Walk, 0=Stand)
        is_walking = ismember(raw_label, cfg.DS.USCHAD.WALKING_LABELS);
        trial_label_binary = double(is_walking);

        % --- Sliding Window Feature Extraction ---
        for k = 1:cfg.STEP_SIZE:(n_samples - cfg.WINDOW_SIZE + 1)
            window_start = k;
            window_end = k + cfg.WINDOW_SIZE - 1;
            
            windowAcc = acc(window_start:window_end, :);
            windowGyro = gyro(window_start:window_end, :);

            % Extract Features (Using updated 5-feature logic)
            feature_vector = Features(windowAcc, windowGyro, cfg.FS);
            
            features = [features; feature_vector]; %#ok<AGROW>
            labels_binary = [labels_binary; trial_label_binary]; %#ok<AGROW>
        end
    end

    % --- 3. Prepare Metadata ---
    % This ensures the Real-time pipeline knows how to match the model
    ModelMetadata.fs = cfg.FS;
    ModelMetadata.windowSize = cfg.WINDOW_SIZE;
    ModelMetadata.stepSize = cfg.STEP_SIZE;
    ModelMetadata.featureCount = size(features, 2);
    ModelMetadata.dateTrained = char(datetime('now'));

    fprintf('Feature extraction complete. Generated %d windows with %d features each.\n', ...
        size(features, 1), size(features, 2));
end
### END OF FILE: PrepareTrainingData.m

### START OF FILE: Classifier.m
### FILE Path: AutomationForExoskeleton/src/classification/Classifier.m
%% Classifier.m
% --------------------------------------------------------------------------
% FUNCTION: [performance] = EvaluateClassifier(test_trial_name)
% PURPOSE: Loads a trained SVM and tests its performance on a specific, 
% held-out single trial from the USC-HAD dataset.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Fixed label handling/binarization)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - ExoConfig.m
% - ImportUschadSingleImu.m
% - Features.m
% --------------------------------------------------------------------------
% NOTES:
% - Calculates window-by-window classification accuracy.
% --------------------------------------------------------------------------

function [performance] = Classifier(test_trial_name)

clc;
cfg = ExoConfig();

% --- 0. Pre-Flight Check ---
model_path = cfg.FILE.SVM_MODEL;
if ~exist(model_path, 'file')
error('Trained SVM Model not found. Please run TrainSvmBinary first.');
end

% --- 1. Load Trained Model and Metadata ---
loaded = load(model_path, 'SVMModel', 'ModelMetadata');
SVMModel = loaded.SVMModel;
ModelMetadata = loaded.ModelMetadata;

FS = ModelMetadata.fs;
WINDOW_SIZE = ModelMetadata.windowSize;
STEP_SIZE = ModelMetadata.stepSize;

fprintf('--- Starting Classifier Evaluation ---\n');
fprintf('Testing on trial: %s (FS: %d Hz)\n', test_trial_name, FS);

% --- 2. Load Test Data and Determine Ground Truth ---
try
% Fix: Corrected function signature call (returns 3 IMU structs)
[back, ~, ~] = ImportUschadSingleImu(test_trial_name); 

% Load the USC structure to get the activity ID for the test trial
loaded_usc = load(cfg.FILE.USCHAD_DATA, 'usc');
raw_activity_id = loaded_usc.usc.(test_trial_name).label;

n_total_samples = size(back.acc, 1);

% Fix: Binarize the ground truth label based on the ModelMetadata
if ismember(raw_activity_id, ModelMetadata.WALKING_LABELS_RAW)
    ground_truth_binary = cfg.STATE_WALKING; % 1
else
    ground_truth_binary = cfg.STATE_STANDING; % 0
end

% Create a ground truth label for every *window*
n_windows = floor((n_total_samples - ModelMetadata.windowSize) / ModelMetadata.stepSize) + 1;
ground_truth_windows = repmat(ground_truth_binary, n_windows, 1);

catch ME
error('Data loading or ground truth determination failed: %s', ME.message);
end

% --- 3. Extract Features for Test Data ---
test_features = [];
window_labels = []; % Store the predicted label for each window

for k = 1:STEP_SIZE:(n_total_samples - WINDOW_SIZE + 1)
    window_start = k;
    window_end = k + WINDOW_SIZE - 1;

    windowAcc = back.acc(window_start:window_end, :);
    windowGyro = back.gyro(window_start:window_end, :); % Include Gyro

    feature_vector = Features(windowAcc, windowGyro, FS);
    test_features = [test_features; feature_vector]; %#ok<AGROW>
end

% --- 4. Classify All Windows ---
predicted_labels = predict(SVMModel, test_features);


% --- 5. Performance Evaluation (Window-by-Window) ---
TP = sum(ground_truth_windows == 1 & predicted_labels == 1);
TN = sum(ground_truth_windows == 0 & predicted_labels == 0);
FP = sum(ground_truth_windows == 0 & predicted_labels == 1);
FN = sum(ground_truth_windows == 1 & predicted_labels == 0);

Accuracy = (TP + TN) / (TP + TN + FP + FN);
Precision = TP / (TP + FP); 
Recall = TP / (TP + FN); 
Specificity = TN / (TN + FP);

performance.TP = TP;
performance.TN = TN;
performance.FP = FP;
performance.FN = FN;
performance.Accuracy = Accuracy;
performance.Precision = Precision;
performance.Recall = Recall;
performance.Specificity = Specificity;

% --- 6. Report Results ---
fprintf('\n--- Classification Performance Summary (Window-by-Window) ---\n');
fprintf('Target Label: %d (WALK=%d, STAND=%d)\n', ground_truth_binary, cfg.STATE_WALKING, cfg.STATE_STANDING);
fprintf('Total Windows: %d\n', n_windows);
fprintf('------------------------------------------\n');
fprintf('Accuracy: %.2f%%\n', Accuracy * 100);
fprintf('Precision: %.2f%%\n', Precision * 100);
fprintf('Recall: %.2f%%\n', Recall * 100);
fprintf('------------------------------------------\n');

end
### END OF FILE: Classifier.m

### START OF FILE: RealtimeFsm.m
### FILE Path: AutomationForExoskeleton/src/classification/RealtimeFsm.m
%% RealtimeFsm.m
% --------------------------------------------------------------------------
% FUNCTION: [command, new_state] = RealtimeFsm(classified_label, current_state)
% PURPOSE: Implements a simple Finite State Machine (FSM) to transition
% the exoskeleton control state based on the SVM classification output.
% It prevents rapid, noisy switching between STANDING (0) and WALKING (1).
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Initial implementation)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - ExoConfig.m (Requires constants for state definitions)
% --------------------------------------------------------------------------
% NOTES:
% - State 0: STANDING/NON-LOCOMOTION
% - State 1: WALKING/LOCOMOTION
% - COMMAND is the output signal for the exoskeleton actuators (0 or 1).
% --------------------------------------------------------------------------

function [command, new_state] = RealtimeFsm(classified_label, current_state)

% Load Configuration for State Constants
cfg = ExoConfig();
STATE_STANDING = cfg.STATE_STANDING; % Should be 0
STATE_WALKING = cfg.STATE_WALKING;   % Should be 1

% --- FSM Parameters (Adjust these for sensitivity/latency trade-off) ---
% The number of consecutive WALKING predictions required to transition from STANDING to WALKING.
WALK_ENTRY_THRESHOLD = 3; 
% The number of consecutive STANDING predictions required to transition from WALKING to STANDING.
STAND_EXIT_THRESHOLD = 5; 

persistent walk_counter stand_counter;

% Initialize counters on first call
if isempty(walk_counter) || isempty(stand_counter)
    walk_counter = 0;
    stand_counter = 0;
end

% --- 1. Update Transition Counters ---

if classified_label == STATE_WALKING
    walk_counter = walk_counter + 1;
    stand_counter = 0; % Reset opposing counter
else % classified_label == STATE_STANDING
    stand_counter = stand_counter + 1;
    walk_counter = 0; % Reset opposing counter
end


% --- 2. State Transition Logic ---

new_state = current_state; % Assume state remains the same

switch current_state
    case STATE_STANDING
        % Current State: STANDING (0)
        
        % Check for transition to WALKING
        if walk_counter >= WALK_ENTRY_THRESHOLD
            new_state = STATE_WALKING;
            % Reset counter for the new state's exit condition
            stand_counter = 0; 
            fprintf('FSM Transition: STANDING -> WALKING\n');
        end
        
    case STATE_WALKING
        % Current State: WALKING (1)
        
        % Check for transition back to STANDING
        if stand_counter >= STAND_EXIT_THRESHOLD
            new_state = STATE_STANDING;
            % Reset counter for the new state's exit condition
            walk_counter = 0;
            fprintf('FSM Transition: WALKING -> STANDING\n');
        end
        
    otherwise
        % Handle unexpected state (should not happen)
        warning('FSM received an unexpected current state: %d. Defaulting to STANDING.', current_state);
        new_state = STATE_STANDING;
        
end


% --- 3. Generate Control Command ---

% The control command is typically the new state itself, representing 
% whether the exoskeleton should be providing locomotion assistance (1) or 
% locked/idle (0).
command = new_state;

end
### END OF FILE: RealtimeFsm.m

### START OF FILE: StateEstimator.m
### FILE Path: AutomationForExoskeleton/src/classification/StateEstimator.m
%% StateEstimator.m
% --------------------------------------------------------------------------
% FUNCTION: [command, state] = updateFSM(new_label, current_state)
% PURPOSE: Implements the Finite State Machine (FSM) to manage transitions between locomotion modes and generate exoskeleton control commands.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-11
% LAST MODIFIED: 2025-12-13
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - None (Self-contained logic)
% --------------------------------------------------------------------------
% NOTES:
% - State smoothing: requires 3 consecutive labels to confirm a state change.
% - The output `command` is a simple low-level signal (e.g., 0=stand, 1=walk gait).
% --------------------------------------------------------------------------

function [command, next_state] = StateEstimator(new_label, current_state)

% --- Configuration Parameters ---
persistent state_counter % Persist across calls to track consecutive labels
if isempty(state_counter)
    state_counter = 0; % 0: Consecutive label counter
end

% Required consecutive labels to confirm a state transition
CONFIRMATION_THRESHOLD = 3; 

% --- State Definitions ---
% Use descriptive integer codes
STATE_STANDING = 0;
STATE_WALKING = 1;

% Assuming new_label comes from SVM (0=Stand, 1=Walk)

% Initialize next state and command to current values
next_state = current_state;
command = current_state; % Command is typically the same as the final state

% ----------------------------------------------------------------
% 1. CHECK FOR CONSISTENCY (Smoothing)
% ----------------------------------------------------------------

if new_label == next_state
    % Label matches current state, reset counter
    state_counter = 0;
    return; % No state change needed
end

% ----------------------------------------------------------------
% 2. CHECK FOR TRANSITION
% ----------------------------------------------------------------

if new_label ~= next_state
    % Label suggests a change; increment counter
    state_counter = state_counter + 1;

    if state_counter >= CONFIRMATION_THRESHOLD
        % Threshold reached: Execute the transition
        
        if current_state == STATE_STANDING && new_label == STATE_WALKING
            % Transition: STANDING -> WALKING
            next_state = STATE_WALKING;
            command = 1; % Low-level command to initiate walking gait
            fprintf('FSM Transition: STANDING -> WALKING\n');

        elseif current_state == STATE_WALKING && new_label == STATE_STANDING
            % Transition: WALKING -> STANDING
            next_state = STATE_STANDING;
            command = 0; % Low-level command to lock/stop exoskeleton
            fprintf('FSM Transition: WALKING -> STANDING\n');
        end

        % Reset counter after successful transition
        state_counter = 0;
    end
end

% If the threshold was not reached, next_state remains current_state
end
### END OF FILE: StateEstimator.m

### START OF FILE: Features.m
### FILE Path: AutomationForExoskeleton/src/features/Features.m
%% Features.m
% --------------------------------------------------------------------------
% FUNCTION: [features_out] = Features(windowAcc, windowGyro, Fs)
% PURPOSE: Extracts a feature vector from a window of IMU data.
% --------------------------------------------------------------------------
% INPUTS:
%   - windowAcc:  Nx3 matrix of Accelerometer data (m/s^2)
%   - windowGyro: Nx3 matrix of Gyroscope data (rad/s)
%   - Fs:         Sampling Frequency (Hz)
% OUTPUTS:
%   - features_out: 1x5 vector [AccMean, AccVar, GyroMean, GyroVar, DomFreq]
% --------------------------------------------------------------------------
% LOCATION: src/features/Features.m
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-11
% LAST MODIFIED: 2025-12-17
% --------------------------------------------------------------------------

function [features_out] = Features(windowAcc, windowGyro, Fs)

    % --- 1. Accelerometer Features ---
    % Calculate magnitude of acceleration vector (net force)
    mag_acc = sqrt(sum(windowAcc.^2, 2));
    
    feat_mean_acc = mean(mag_acc); % Mean intensity
    feat_var_acc  = var(mag_acc);  % Variability/Energy

    % --- 2. Gyroscope Features (NEW) ---
    % Calculate magnitude of rotational velocity
    mag_gyro = sqrt(sum(windowGyro.^2, 2));
    
    feat_mean_gyro = mean(mag_gyro); % Is the body rotating?
    feat_var_gyro  = var(mag_gyro);  % How erratic is the rotation?

    % --- 3. Frequency-Domain Features ---
    N = length(windowAcc);
    
    % Edge case protection for tiny windows
    if N < 2
        features_out = [feat_mean_acc, feat_var_acc, feat_mean_gyro, feat_var_gyro, 0];
        return; 
    end

    % Perform FFT on Z-axis acceleration (Gravity axis usually has strongest gait signal)
    acc_z = windowAcc(:, 3); 
    
    Y = fft(acc_z);
    P2 = abs(Y/N);
    P1 = P2(1:floor(N/2)+1); % Single-sided spectrum
    P1(2:end-1) = 2*P1(2:end-1);

    % Frequency vector
    f = Fs*(0:floor(N/2))/N;

    % Find Dominant Frequency (exclude DC component at index 1)
    [~, idx] = max(P1(2:end)); 
    feat_dom_freq = f(idx + 1); 

    % --- 4. Assemble Output ---
    features_out = [feat_mean_acc, feat_var_acc, feat_mean_gyro, feat_var_gyro, feat_dom_freq];

end
### END OF FILE: Features.m

### START OF FILE: FusionKalman.m
### FILE Path: AutomationForExoskeleton/src/fusion/FusionKalman.m
%% FusionKalman.m
% --------------------------------------------------------------------------
% CLASS: FusionKalman
% PURPOSE: Static helper class for Kinematics and Sensor Fusion.
%          Contains methods to initialize filters and calculate joint angles.
% --------------------------------------------------------------------------
% LOCATION: src/fusion/FusionKalman.m
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-11
% LAST MODIFIED: 2025-12-17
% --------------------------------------------------------------------------

classdef FusionKalman
    methods (Static)
        function [fuse_back, fuse_hipL] = initializeFilters(Fs)
            % initializeFilters: Sets up IMU filters for Back and Hip.
            % Tuning parameters (Optimized for human motion)
            ACCEL_NOISE = 0.01; 
            GYRO_NOISE = 0.005;

            fprintf('Initializing Kalman IMU Filters (SampleRate: %d Hz)...\n', Fs);
            
            % Filter for Back IMU
            fuse_back = imufilter('SampleRate', Fs, ...
                'AccelerometerNoise', ACCEL_NOISE, ...
                'GyroscopeNoise', GYRO_NOISE, ...
                'ReferenceFrame', 'ENU');

            % Filter for Left Hip IMU
            fuse_hipL = imufilter('SampleRate', Fs, ...
                'AccelerometerNoise', ACCEL_NOISE, ...
                'GyroscopeNoise', GYRO_NOISE, ...
                'ReferenceFrame', 'ENU');
        end
        
        function hipFlexionAngle = estimateAngle(orientBack, orientHipL)
            % estimateAngle: Computes relative joint angle (flexion/pitch) 
            % between the Back and the Hip.
            
            % Input check
            if any(isnan(orientBack)) || any(isnan(orientHipL))
                hipFlexionAngle = 0;
                return;
            end
        
            % Convert Quaternions to Euler Angles (ZYX order)
            % Index 2 corresponds to Pitch (Y-axis rotation), usually Flexion/Extension
            eulBack = quat2eul(orientBack, 'ZYX');
            eulHipL = quat2eul(orientHipL, 'ZYX');
        
            % Calculate Relative Angle
            angle_rad = eulHipL(2) - eulBack(2);
            
            % Convert to Degrees
            hipFlexionAngle = angle_rad * (180/pi);
        end
    end
end
### END OF FILE: FusionKalman.m

### START OF FILE: acquisition_test.m
### FILE Path: AutomationForExoskeleton/tests/acquisition_test.m

### END OF FILE: acquisition_test.m

### START OF FILE: classification_test.m
### FILE Path: AutomationForExoskeleton/tests/classification_test.m

### END OF FILE: classification_test.m

