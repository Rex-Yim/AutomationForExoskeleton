--- CONCATENATED CODE FROM PROJECT: AutomationForExoskeleton ---

### START OF FILE: ExoConfig.m
### FILE Path: AutomationForExoskeleton/config/ExoConfig.m
%% ExoConfig.m
% --------------------------------------------------------------------------
% PURPOSE: Defines all global configuration parameters, constants, and 
% hyperparameters for the exoskeleton control pipeline.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Updated USC-HAD labels)
% --------------------------------------------------------------------------
% NOTES:
% - Edit this file to tune the system (e.g., Fs, window size, Kalman noise).
% - All other scripts should load these variables using a function call.
% --------------------------------------------------------------------------

function cfg = ExoConfig()
% --- General System Parameters ---
cfg.FS = 100; % Sample Rate (Hz) - Matches USC-HAD
cfg.ACTIVITY_SIMULATION = 'walking_straight'; % Default raw folder for pipeline simulation
% --- Classification Parameters (Locomotion Mode) ---
cfg.WINDOW_SIZE_S = 1.0; % Window duration in seconds
cfg.STEP_SIZE_S = 0.5; % Step duration in seconds (50% overlap)
cfg.WINDOW_SIZE = round(cfg.WINDOW_SIZE_S * cfg.FS);
cfg.STEP_SIZE = round(cfg.STEP_SIZE_S * cfg.FS);
% SVM Model Parameters
cfg.SVM_KERNEL = 'rbf';
cfg.SVM_STANDARDIZE = true;
% FSM Parameters
cfg.FSM_CONFIRMATION_THRESHOLD = 3; % Consecutive labels required for state change
cfg.STATE_STANDING = 0;
cfg.STATE_WALKING = 1;
% Dataset Specific Labels (USC-HAD)
% Fix: Expanded labels to cover all activities (1-6 locomotion, 7-12 non-locomotion)
cfg.DS.USCHAD.WALKING_LABELS = [1, 2, 3, 4, 5, 6]; % WalkForward, WalkLeft, WalkRight, Upstairs, Downstairs, RunForward
cfg.DS.USCHAD.NON_WALKING_LABELS = [7, 8, 9, 10, 11, 12]; % Jump, Sit, Stand, Sleep, ElevatorUp, ElevatorDown
% --- Sensor Fusion Parameters (Kalman Filter) ---
% Tuning parameters to achieve RMSE < 5 deg
cfg.KALMAN.ACCEL_NOISE = 0.01; 
cfg.KALMAN.GYRO_NOISE = 0.005;
% --- File Paths & Names ---
cfg.FILE.SVM_MODEL = 'results/Binary_SVM_Model.mat';
cfg.FILE.USCHAD_DATA = 'data/public/USC-HAD/usc_had_dataset.mat';
% CRITICAL FIX: Added the missing configuration variable for the raw data folder
cfg.FILE.USCHAD_FOLDER = 'data/public/USC-HAD/USC-HAD_raw';
cfg.FILE.HUGADB_DATA = 'data/public/HuGaDB/hugadb_dataset.mat';
end
### END OF FILE: ExoConfig.m

### START OF FILE: LoadHuGaDB.m
### FILE Path: AutomationForExoskeleton/data/public/HuGaDB/LoadHuGaDB.m
%% LoadHuGaDB.m
% --------------------------------------------------------------------------
% FUNCTION: [] = LoadHuGaDB()
% PURPOSE: Loads all raw HuGaDB text files, parses the data, and saves it 
%          to a single .mat file, structured for use with the project's 
%          three-IMU (Back, HipL, HipR) pipeline convention.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-12
% LAST MODIFIED: 2025-12-14 (Restructured output for pipeline compatibility)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - dlmread (MATLAB built-in)
% --------------------------------------------------------------------------
% NOTES:
% - HuGaDB Sensor Mapping:
%   - Project's HipL -> HuGaDB Left Thigh (lt)
%   - Project's HipR -> HuGaDB Right Thigh (rt)
%   - Project's Back -> Dummy zeros (HuGaDB lacks a dedicated back sensor)
% --------------------------------------------------------------------------

clear; clc;

dataDir = 'HuGaDB_v2_raw'; % Path to .txt files
outputFile = 'hugadb_dataset.mat';

files = dir(fullfile(dataDir, '*.txt'));
hugadb_data = struct(); % Store all sessions

if isempty(files)
    error('No raw HuGaDB .txt files found in %s.', dataDir);
end

fprintf('Loading and restructuring %d HuGaDB trials...\n', length(files));

% Activity ID to Name mapping (simplified example for HuGaDB)
% Labels in HuGaDB are: 1=Sit, 2=Stand, 3=SitToStand, 4=StandToSit, 5=Walk, 6=StairsUp, 7=StairsDown, 8=Run
activityNames = {'Sit', 'Stand', 'SitToStand', 'StandToSit', 'Walk', 'StairsUp', 'StairsDown', 'Run'};

for i = 1:length(files)
    filePath = fullfile(dataDir, files(i).name);
    % Skips 4 header lines using dlmread
    rawMatrix = dlmread(filePath, '\t', 4, 0); 

    % --- 1. Parse Raw Data (Column indices based on standard HuGaDB format) ---
    
    % Data for Hip L (using Left Thigh IMU)
    data.hipL.acc = rawMatrix(:, 31:33); % Left thigh accel
    data.hipL.gyro = rawMatrix(:, 34:36); % Left thigh gyro

    % Data for Hip R (using Right Thigh IMU)
    data.hipR.acc = rawMatrix(:, 13:15); % Right thigh accel
    data.hipR.gyro = rawMatrix(:, 16:18); % Right thigh gyro

    % Data for Back (Dummy zero data to satisfy pipeline input)
    data.back.acc = zeros(size(data.hipL.acc));
    data.back.gyro = zeros(size(data.hipL.gyro));

    % Activity label and Metadata
    label = rawMatrix(:, 39); % Activity label
    data.label = label(1); % Use the first label as the trial label (assuming single activity per file)
    data.activityName = activityNames{data.label};
    data.fs = 100; % Assuming 100 Hz for HuGaDB (common rate)
    
    % Store the full label vector separately if needed for time-series analysis
    data.labels_full = label; 
    
    % --- 2. Store in Main Structure ---
    sessionID = files(i).name(1:end-4); % e.g., 'HuGaDB_v2_various_01_00'
    hugadb_data.(sessionID) = data;
end

save(outputFile, 'hugadb_data', '-v7.3');
fprintf('HuGaDB saved as %s (%d trials) with pipeline-compatible structure.\n', outputFile, length(files));
### END OF FILE: LoadHuGaDB.m

### START OF FILE: ImportUschadSingleImu.m
### FILE Path: AutomationForExoskeleton/data/public/USC-HAD/ImportUschadSingleImu.m
%% ImportUschadSingleImu.m
% --------------------------------------------------------------------------
% FUNCTION: [back, hipL, hipR] = import_uschad_for_pipeline(trialFieldName)
% PURPOSE: Adapts the single-IMU USC-HAD data format to match the project's three-IMU pipeline, assigning the real data to the 'back' sensor.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-12
% LAST MODIFIED: 2025-12-12
% --------------------------------------------------------------------------
% DEPENDENCIES: 
%   - usc_had_dataset.mat
% --------------------------------------------------------------------------
% NOTES:
%   - `hipL` and `hipR` are returned as dummy zero arrays to satisfy pipeline function signatures.
%   - Used for pipeline validation when only one IMU is required.
% --------------------------------------------------------------------------

function [back, hipL, hipR] = ImportUschadSingleImu(trialFieldName)

load('data/public/USC-HAD/usc_had_dataset.mat', 'usc');

trial = usc.(trialFieldName);

back.acc  = trial.acc;
back.gyro = trial.gyro;

% Dummy placeholders (your Kalman/SVM only uses back for many tests anyway)
hipL.acc  = zeros(size(back.acc));
hipL.gyro = zeros(size(back.gyro));
hipR.acc  = zeros(size(back.acc));
hipR.gyro = zeros(size(back.gyro));

fprintf('Loaded USC-HAD trial %s → back sensor (label = %d: %s)\n', ...
        trialFieldName, trial.label, trial.activityName);
end
### END OF FILE: ImportUschadSingleImu.m

### START OF FILE: LoadUSCHAD.m
### FILE Path: AutomationForExoskeleton/data/public/USC-HAD/LoadUSCHAD.m
%% LoadUSCHAD.m
% --------------------------------------------------------------------------
% FUNCTION: [usc] = loadUSCHAD(rawDir)
% PURPOSE: Loads all raw USC-HAD `.mat` files, normalizes the structure, and saves all trials into a single `usc_had_dataset.mat` file.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-12
% LAST MODIFIED: 2025-12-15 (Fixed rawDir path and subject ID parsing)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - MATLAB built-in functions (dir, load, regexp)
% --------------------------------------------------------------------------
% NOTES:
% - Converts USC-HAD's gyro format (3xN) to standard (Nx3).
% - Saves the activity name and label (1-12) for each trial.
% --------------------------------------------------------------------------

function usc = LoadUSCHAD(rawDir)

if nargin < 1
% Fix: Corrected folder name from 'RawData' to 'USC-HAD_raw'
rawDir = fullfile('data/public/USC-HAD/USC-HAD_raw'); 
end

if ~isfolder(rawDir)
error('USC-HAD RawData folder not found: %s', rawDir);
end

files = dir(fullfile(rawDir, '*.mat'));
usc = struct();

activityNames = {'WalkForward','WalkLeft','WalkRight','GoUpstairs',...
'GoDownstairs','RunForward','Jump','Sit','Stand',...
'Sleep','ElevatorUp','ElevatorDown'};

fprintf('Loading %d USC-HAD trials...\n', length(files));

for i = 1:length(files)
filepath = fullfile(rawDir, files(i).name);
tmp = load(filepath); % contains 'sensor_data'

% Extract fields
acc = tmp.sensor_data.acc; % Nx3 (already in m/s²)
gyro = tmp.sensor_data.gyro'; % 3xN → Nx3 (rad/s)

% Parse filename: e.g., a1_t2_s3.mat → activity 1, trial 2, subject 3
tokens = regexp(files(i).name, 'a(?<act>\d+)_t(?<trial>\d+)_s(?<subj>\d+)', 'names');
actID = str2double(tokens.act);
% Fix: Removed incorrect indexing that stripped the first digit (e.g., s10 would become 0)
subjID = str2double(tokens.subj); 

fieldName = sprintf('subject%d_activity%d_trial%d', subjID, actID, str2double(tokens.trial));

usc.(fieldName).acc = acc;
usc.(fieldName).gyro = gyro;
usc.(fieldName).label = actID; % 1-12
usc.(fieldName).subject = subjID;
usc.(fieldName).activityName = activityNames{actID};
usc.(fieldName).fs = 100;
end

save('data/public/USC-HAD/usc_had_dataset.mat', 'usc', '-v7.3');
fprintf('USC-HAD saved as usc_had_dataset.mat (%d trials)\n', length(files));
end
### END OF FILE: LoadUSCHAD.m

### START OF FILE: RunExoskeletonPipeline.m
### FILE Path: AutomationForExoskeleton/scripts/RunExoskeletonPipeline.m
%% RunExoskeletonPipeline.m
% --------------------------------------------------------------------------
% FUNCTION: [] = RunExoskeletonPipeline()
% PURPOSE: Main script to simulate the real-time exoskeleton control system. 
% It integrates Data Acquisition, Sensor Fusion (Kalman), 
% and Locomotion Classification (SVM/FSM) to generate control commands.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Fixed missing gyro data and Kalman interface)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - ImportData.m
% - Features.m
% - RealtimeFsm.m
% - FusionKalman.m 
% - Binary_SVM_Model.mat 
% --------------------------------------------------------------------------
% NOTES:
% - Simulates real-time data flow by iterating over the imported batch data.
% --------------------------------------------------------------------------

clc; clear; close all;

% --- Configuration (Use ExoConfig for centralized management) ---
cfg = ExoConfig();
ACTIVITY_NAME = cfg.ACTIVITY_SIMULATION; 
FS = cfg.FS; 
WINDOW_SIZE = cfg.WINDOW_SIZE; 
STEP_SIZE = cfg.STEP_SIZE; 

% --- 1. Load Trained Model ---
model_path = cfg.FILE.SVM_MODEL;
if ~exist(model_path, 'file')
error('Trained SVM Model not found. Please run TrainSvmBinary first to generate: %s', model_path);
end
load(model_path, 'SVMModel');
fprintf('Trained SVM Model loaded successfully.\n');

% --- 2. Initialize Exoskeleton State ---
current_fsm_state = cfg.STATE_STANDING; % 0: STANDING, 1: WALKING
hip_flexion_angles = []; % Store estimated joint angles

% --- 3. Initialize Sensor Fusion Filter (Kalman) ---
% Using the new modular function from FusionKalman.m
[fuse_back, fuse_hipL] = initializeFilters(FS); 
fprintf('Kalman Filter initialized for real-time operation.\n');

% --- 4. Load Data for Simulation (Data Acquisition Protocol) ---
try
[back, hipL, ~, annotations] = ImportData(ACTIVITY_NAME); 
catch ME
warning('Data import failed via ImportData.m: %s. Falling back to dummy data.', ME.message);
% Dummy data fallback if ImportData fails to read CSVs
data_len = 5000;
back.acc = [zeros(data_len, 2), ones(data_len, 1)*9.8];
back.gyro = zeros(data_len, 3);
hipL = struct('acc', zeros(data_len, 3), 'gyro', zeros(data_len, 3));
annotations = table(zeros(data_len, 1), 'VariableNames', {'Label'}); 
end

n_total_samples = size(back.acc, 1);
fprintf('Starting real-time simulation on %d samples...\n', n_total_samples);

% --- 5. Main Real-Time Simulation Loop ---
fsm_plot = zeros(n_total_samples, 1);
last_command = 0;

for i = 1:n_total_samples

% --- Sensor Fusion (Incremental Update) ---
% 1. Update IMU filters with current sample (i). The filter object's state is updated internally.
update(fuse_back, back.acc(i,:), back.gyro(i,:));
update(fuse_hipL, hipL.acc(i,:), hipL.gyro(i,:));

% 2. Calculate current hip flexion angle
% Fix: Pass the filter objects (which hold the state) directly.
current_angle = estimateAngle(fuse_back, fuse_hipL); 
hip_flexion_angles(i) = current_angle; %#ok<AGROW>

% --- Locomotion Classification (Sliding Window Check) ---
if mod(i - 1, STEP_SIZE) == 0 && (i + WINDOW_SIZE - 1) <= n_total_samples

windowAcc = back.acc(i : i+WINDOW_SIZE-1, :);
windowGyro = back.gyro(i : i+WINDOW_SIZE-1, :); % Fix: Extract Gyro window

% 1. Extract Features
% Fix: Pass both Accel and Gyro to Features.m
features_vec = Features(windowAcc, windowGyro, FS); 

% 2. Classify (Predict the next label)
new_label = predict(SVMModel, features_vec); 

% 3. Update FSM and get command
[exoskeleton_command, current_fsm_state] = RealtimeFsm(new_label, current_fsm_state);

last_command = exoskeleton_command; 

fprintf('Time step %d: Classification Label=%d, FSM State=%d, Command=%d\n', ...
i, new_label, current_fsm_state, exoskeleton_command);
end

% Store the current command for this sample index
fsm_plot(i) = last_command;
end

% --- 6. Visualization and Finalization ---
fprintf('\nPipeline simulation complete.\n');

figure('Name', 'Pipeline Output');
t = (1:n_total_samples) / FS;

subplot(3,1,1);
plot(t, hip_flexion_angles, 'LineWidth', 1.5);
title('Estimated Left Hip Flexion Angle (Kalman)');
ylabel('Angle (deg)');
grid on;

subplot(3,1,2);
stairs(t, fsm_plot, 'LineWidth', 1.5);
ylim([-0.1 1.1]);
yticks([0 1]);
yticklabels({'STANDING', 'WALKING'});
title('Exoskeleton Control Command (FSM Output)');
ylabel('Command');
grid on;

subplot(3,1,3);
if ismember('Label', annotations.Properties.VariableNames) && size(annotations, 1) == n_total_samples
plot(t, annotations.Label, 'LineWidth', 1.5, 'Color', 'k');
title('Ground Truth Label (from Annotation.csv)');
xlabel('Time (s)');
ylabel('Label');
grid on;
else
text(0.5, 0.5, 'Ground Truth plotting skipped (size mismatch or missing data).', 'HorizontalAlignment', 'center');
title('Ground Truth Label');
xlabel('Time (s)');
end

saveas(gcf, 'results/realtime_pipeline_output.png');
fprintf('Output plot saved to results/realtime_pipeline_output.png\n');
### END OF FILE: RunExoskeletonPipeline.m

### START OF FILE: TestPipelinePerformance.m
### FILE Path: AutomationForExoskeleton/scripts/TestPipelinePerformance.m
%% TestPipelinePerformance.m
% --------------------------------------------------------------------------
% FUNCTION: [metrics] = TestPipelinePerformance()
% PURPOSE: Runs the full real-time simulation pipeline and evaluates the 
% locomotion classification performance against ground truth labels.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Fixed ground truth binarization and missing gyro data)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - ExoConfig.m
% - ImportData.m
% - Features.m
% - RealtimeFsm.m
% - FusionKalman.m
% - Binary_SVM_Model.mat (Trained model)
% --------------------------------------------------------------------------
% NOTES:
% - Loads ground truth from Annotation.csv for the simulated activity.
% - Calculates Accuracy, Precision (Positive Predictive Value), and Recall (Sensitivity).
% --------------------------------------------------------------------------

function [metrics] = TestPipelinePerformance()

clc; close all;
cfg = ExoConfig();

% --- 0. Pre-Flight Check ---
model_path = cfg.FILE.SVM_MODEL;
if ~exist(model_path, 'file')
error('Trained SVM Model not found. Please run TrainSvmBinary first.');
end

% --- 1. Load Trained Model and Configuration ---
% Need to load ModelMetadata to ensure compatibility, even if not fully used here
loaded = load(model_path, 'SVMModel', 'ModelMetadata');
SVMModel = loaded.SVMModel;
ModelMetadata = loaded.ModelMetadata;

FS = ModelMetadata.fs;
WINDOW_SIZE = ModelMetadata.windowSize;
STEP_SIZE = ModelMetadata.stepSize;
ACTIVITY_NAME = cfg.ACTIVITY_SIMULATION;

fprintf('--- Starting Full Pipeline Performance Test ---\n');
fprintf('Simulating Activity: %s (FS: %d Hz)\n', ACTIVITY_NAME, FS);

% --- 2. Load Data and Ground Truth ---
try
[back, hipL, ~, annotations] = ImportData(ACTIVITY_NAME); 
n_total_samples = size(back.acc, 1);

if ~ismember('Label', annotations.Properties.VariableNames) || size(annotations, 1) ~= n_total_samples
error('Annotation file is invalid or size mismatch. Cannot perform evaluation.');
end

ground_truth = annotations.Label; % Multi-class label (e.g., 1, 4, 8)

% Fix: Binarize the ground truth label to match the FSM output (0 or 1)
walking_labels = cfg.DS.USCHAD.WALKING_LABELS; 
non_walking_labels = cfg.DS.USCHAD.NON_WALKING_LABELS; 

ground_truth_binary = zeros(size(ground_truth));
% Map locomotion labels to 1 (WALKING)
ground_truth_binary(ismember(ground_truth, walking_labels)) = cfg.STATE_WALKING; 
% Map non-locomotion labels to 0 (STANDING)
ground_truth_binary(ismember(ground_truth, non_walking_labels)) = cfg.STATE_STANDING; 

catch ME
error('Data loading or ground truth check failed: %s', ME.message);
end

% --- 3. Run Simulation (Simplified Pipeline Loop) ---

% Initialize states and filters
current_fsm_state = cfg.STATE_STANDING; 
fsm_plot = zeros(n_total_samples, 1);
last_command = 0;
% Filters are initialized in RunExoskeletonPipeline, but we initialize here too
[fuse_back, fuse_hipL] = initializeFilters(FS); 

for i = 1:n_total_samples

% Kinematics (Run but results discarded here, focus is on classification)
update(fuse_back, back.acc(i,:), back.gyro(i,:));
update(fuse_hipL, hipL.acc(i,:), hipL.gyro(i,:)); 

% Classification Check
if mod(i - 1, STEP_SIZE) == 0 && (i + WINDOW_SIZE - 1) <= n_total_samples

windowAcc = back.acc(i : i+WINDOW_SIZE-1, :);
windowGyro = back.gyro(i : i+WINDOW_SIZE-1, :); % Fix: Extract Gyro window

% Fix: Pass both Accel and Gyro to Features.m
features_vec = Features(windowAcc, windowGyro, FS); 
new_label = predict(SVMModel, features_vec); 

[exoskeleton_command, current_fsm_state] = RealtimeFsm(new_label, current_fsm_state);
last_command = exoskeleton_command; 
end

fsm_plot(i) = last_command;
end

% --- 4. Performance Evaluation ---

% We compare the FSM output (fsm_plot) against the binarized ground truth.
% True Positives (TP): Walk predicted as Walk
% Fix: Use ground_truth_binary instead of raw ground_truth
TP = sum(ground_truth_binary == 1 & fsm_plot == 1);
% True Negatives (TN): Stand predicted as Stand
TN = sum(ground_truth_binary == 0 & fsm_plot == 0);
% False Positives (FP): Stand predicted as Walk (Type I Error)
FP = sum(ground_truth_binary == 0 & fsm_plot == 1);
% False Negatives (FN): Walk predicted as Stand (Type II Error)
FN = sum(ground_truth_binary == 1 & fsm_plot == 0);

% Calculate Metrics
Accuracy = (TP + TN) / (TP + TN + FP + FN);
Precision = TP / (TP + FP); % How many predicted 'Walks' were correct
Recall = TP / (TP + FN); % How many actual 'Walks' were caught
Specificity = TN / (TN + FP); % How many actual 'Stands' were caught

metrics.TP = TP;
metrics.TN = TN;
metrics.FP = FP;
metrics.FN = FN;
metrics.Accuracy = Accuracy;
metrics.Precision = Precision;
metrics.Recall = Recall;
metrics.Specificity = Specificity;


% --- 5. Report Results ---
fprintf('\n--- Classification Performance Summary ---\n');
fprintf('Target Activity: %s\n', ACTIVITY_NAME);
fprintf('Total Samples: %d\n', n_total_samples);
fprintf('------------------------------------------\n');
fprintf('True Positives (TP): %d\n', TP);
fprintf('True Negatives (TN): %d\n', TN);
fprintf('False Positives (FP): %d\n', FP);
fprintf('False Negatives (FN): %d\n', FN);
fprintf('------------------------------------------\n');
fprintf('SYSTEM ACCURACY: %.2f%%\n', Accuracy * 100);
fprintf('PRECISION (Walk): %.2f%%\n', Precision * 100);
fprintf('RECALL (Walk): %.2f%%\n', Recall * 100);
fprintf('SPECIFICITY (Stand): %.2f%%\n', Specificity * 100);
fprintf('------------------------------------------\n');

end
### END OF FILE: TestPipelinePerformance.m

### START OF FILE: TrainSvmBinary.m
### FILE Path: AutomationForExoskeleton/scripts/TrainSvmBinary.m
%% TrainSvmBinary.m
% --------------------------------------------------------------------------
% FUNCTION: [SVMModel, metrics] = TrainSvmBinary()
% PURPOSE: Trains a binary Support Vector Machine (SVM) classifier for
% Locomotion (1) vs. Static (0) using data from the USC-HAD dataset,
% and saves the model for the real-time pipeline.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Fixed subject-wise splitting logic)
% --------------------------------------------------------------------------
% DEPENDENCIES:
% - ExoConfig.m
% - LoadUSCHAD.m (or any data loading function that returns IMU data)
% - PrepareTrainingData.m
% - Features.m
% --------------------------------------------------------------------------
% NOTES:
% - Uses a 70/30 Subject-wise split for training/testing.
% - Classification is Locomotion (1) vs. Non-Locomotion (0).
% --------------------------------------------------------------------------
function [SVMModel, metrics] = TrainSvmBinary()
clc; clear; close all;
% --- 1. Configuration and Setup ---
cfg = ExoConfig();
% Training parameters
FS = cfg.FS;
WINDOW_SIZE = cfg.WINDOW_SIZE;
STEP_SIZE = cfg.STEP_SIZE;
C_SVM = 1;               % SVM Box Constraint
KERNEL_FUNCTION = 'linear'; % Or 'rbf' for a non-linear boundary
% File paths for data and model saving
model_save_path = cfg.FILE.SVM_MODEL;

fprintf('--- Starting Binary SVM Training Pipeline ---\n');
fprintf('Activity Window: %d samples (%.2f s), Step: %d samples\n', WINDOW_SIZE, WINDOW_SIZE/FS, STEP_SIZE);
fprintf('Kernel Function: %s, Box Constraint (C): %.1f\n', KERNEL_FUNCTION, C_SVM);

% --- 2. Data Acquisition and Splitting (LOGIC FIX APPLIED HERE) ---
try
    % FIX: Load the pre-processed .mat file, which should contain the 'usc' structure
    data_file = cfg.FILE.USCHAD_DATA;
    fprintf('Loading USC-HAD data from: %s...\n', data_file);

    if ~exist(data_file, 'file')
        error('Pre-processed data file not found. Please run LoadUSCHAD.m first to generate it.');
    end
    
    loaded = load(data_file, 'usc');
    all_trials_struct = loaded.usc;

catch ME
    error('Data loading failed. Error: %s', ME.message);
end

% Extract unique subject IDs for subject-wise splitting
all_field_names = fieldnames(all_trials_struct);
% Extract subject ID (e.g., 3 from 'subject3_activity...')
subject_ids_per_trial = cellfun(@(x) sscanf(x, 'subject%d_activity%*d_trial%*d', 1), all_field_names);
unique_subjects = unique(subject_ids_per_trial);

n_subjects = length(unique_subjects);
rng(1); % For reproducibility

% Perform subject-wise split
cv_split = cvpartition(n_subjects, 'Holdout', 0.3);
train_subject_indices = find(cv_split.training);
test_subject_indices = find(cv_split.test);

train_subjects = unique_subjects(train_subject_indices);
test_subjects = unique_subjects(test_subject_indices);

fprintf('Total subjects found: %d. Training subjects: %d, Testing subjects: %d.\n', ...
    n_subjects, length(train_subjects), length(test_subjects));

% Select the field names belonging to the training/testing subjects
train_trial_names = all_field_names(ismember(subject_ids_per_trial, train_subjects));
test_trial_names = all_field_names(ismember(subject_ids_per_trial, test_subjects));

% Reorganize the data into a cell array of trial structs for PrepareTrainingData
all_train_trials = cellfun(@(name) all_trials_struct.(name), train_trial_names, 'UniformOutput', false);
all_test_trials = cellfun(@(name) all_trials_struct.(name), test_trial_names, 'UniformOutput', false);

% --- 3. Feature Extraction and Label Preparation ---
fprintf('Extracting features from training data...\n');
% PrepareTrainingData now correctly receives a cell array of trial structs
[X_train, Y_train] = PrepareTrainingData(all_train_trials, cfg, FS, WINDOW_SIZE, STEP_SIZE);

fprintf('Training Data Matrix (X_train) size: %s\n', mat2str(size(X_train)));
fprintf('Training Label Vector (Y_train) size: %s\n', mat2str(size(Y_train)));

% Check for data balance (important for binary classification)
n_locomotion = sum(Y_train == cfg.STATE_WALKING);
n_static = sum(Y_train == cfg.STATE_STANDING);
fprintf('Training Samples: Locomotion (1): %d, Static (0): %d\n', n_locomotion, n_static);

% --- 4. Model Training (Support Vector Machine) ---
fprintf('Starting SVM training...\n');
% Train a binary classifier
t_start = tic;
SVMModel = fitcsvm(X_train, Y_train, ...
    'KernelFunction', KERNEL_FUNCTION, ...
    'BoxConstraint', C_SVM, ...
    'Standardize', true, ...
    'ClassNames', [cfg.STATE_STANDING, cfg.STATE_WALKING]); % Ensure classes are recognized as 0 and 1
t_elapsed = toc(t_start);
fprintf('SVM training completed in %.2f seconds.\n', t_elapsed);

% --- 5. Model Testing (Evaluation on Holdout Set) ---
fprintf('Extracting features from testing data...\n');
% PrepareTrainingData now correctly receives a cell array of trial structs
[X_test, Y_test] = PrepareTrainingData(all_test_trials, cfg, FS, WINDOW_SIZE, STEP_SIZE);

% Predict labels on the test set
Y_pred = predict(SVMModel, X_test);

% Calculate Performance Metrics
TP = sum(Y_test == cfg.STATE_WALKING & Y_pred == cfg.STATE_WALKING);
TN = sum(Y_test == cfg.STATE_STANDING & Y_pred == cfg.STATE_STANDING);
FP = sum(Y_test == cfg.STATE_STANDING & Y_pred == cfg.STATE_WALKING);
FN = sum(Y_test == cfg.STATE_WALKING & Y_pred == cfg.STATE_STANDING);

Accuracy = (TP + TN) / (TP + TN + FP + FN);
Precision = TP / (TP + FP);
Recall = TP / (TP + FN); % Sensitivity
Specificity = TN / (TN + FP);

metrics.TP = TP;
metrics.TN = TN;
metrics.FP = FP;
metrics.FN = FN;
metrics.Accuracy = Accuracy;
metrics.Precision = Precision;
metrics.Recall = Recall;
metrics.Specificity = Specificity;

fprintf('\n--- Test Set Performance Summary (Holdout Subjects) ---\n');
fprintf('Total Test Samples: %d\n', length(Y_test));
fprintf('------------------------------------------\n');
fprintf('True Positives (TP): %d\n', TP);
fprintf('True Negatives (TN): %d\n', TN);
fprintf('False Positives (FP): %d\n', FP);
fprintf('False Negatives (FN): %d\n', FN);
fprintf('------------------------------------------\n');
fprintf('Accuracy: %.2f%%\n', Accuracy * 100);
fprintf('Precision (Walk): %.2f%%\n', Precision * 100);
fprintf('Recall (Walk): %.2f%%\n', Recall * 100);
fprintf('Specificity (Stand): %.2f%%\n', Specificity * 100);
fprintf('------------------------------------------\n');

% --- 6. Save the Model and Metadata ---
% Metadata needed by the real-time pipeline scripts
ModelMetadata.fs = FS;
ModelMetadata.windowSize = WINDOW_SIZE;
ModelMetadata.stepSize = STEP_SIZE;
ModelMetadata.trainSubjects = train_subjects;
ModelMetadata.testSubjects = test_subjects;
save(model_save_path, 'SVMModel', 'ModelMetadata');

fprintf('\nTrained SVM Model and Metadata saved successfully to: %s\n', model_save_path);
end
### END OF FILE: TrainSvmBinary.m

### START OF FILE: ConcatenateCode.m
### FILE Path: AutomationForExoskeleton/scripts/utils/ConcatenateCode.m
%% ConcatenateCode.m
% --------------------------------------------------------------------------
% FUNCTION: [] = ConcatenateCode()
% PURPOSE: Generates a single, structured file (concatenated_code.txt) 
%          containing the source code of the entire project.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-12
% LAST MODIFIED: 2025-12-15 (Fixed path logic to be location-independent)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
%   - MATLAB built-in file I/O and utility functions (mfilename, fileparts, fullfile, mkdir).
% --------------------------------------------------------------------------
% NOTES:
%   - This version automatically determines the project root by locating the 
%     'scripts/utils' folder (where this script resides) and navigating two 
%     levels up.
%   - The script will work correctly no matter where it is called from, as 
%     long as it remains in 'scripts/utils/'.
%   - Uses '###' headers for visibility and structure.
%   - Output is saved to: [Project Root]/scripts/utils/concatenated_code.txt
% --------------------------------------------------------------------------

% --- Define Paths (Location-Independent Logic) ---

% 1. Get the full path to the currently running script (ConcatenateCode.m)
this_script_path = mfilename('fullpath');
if isempty(this_script_path)
    error('Could not determine script path. Ensure it is saved and on the MATLAB path.');
end

% 2. Determine the project root by traversing up two levels from the script's folder:
%    /scripts/utils/ConcatenateCode.m -> /scripts/utils/ -> /scripts/ -> /AutomationForExoskeleton/
output_dir = fileparts(this_script_path);    % Gets the /scripts/utils/ folder (where output is saved)
scripts_dir = fileparts(output_dir);         % Gets the /scripts/ folder
search_root = fileparts(scripts_dir);        % Gets the /AutomationForExoskeleton/ folder (the project root)

% 3. Extract the project name from the root folder
[~, project_name, ~] = fileparts(search_root);
project_name = strrep(project_name, filesep, '');

% 4. Define the output file path (output_dir is already /scripts/utils/)
output_filename = 'concatenated_code.txt';
output_full_path = fullfile(output_dir, output_filename);

% Ensure the output directory exists
if ~exist(output_dir, 'dir')
    mkdir(output_dir);
end
% --------------------------------------------------

fprintf('Starting code concatenation for copying...\n');

% 1. Find all .m files recursively and filter hidden folders
search_path = fullfile(search_root, '**', '*.m');
listing = dir(search_path);

files_to_concatenate = [];
for i = 1:length(listing)
    full_path = fullfile(listing(i).folder, listing(i).name);
    
    % Get the path relative to the true project root
    rel_path = extractAfter(full_path, search_root);
    if startsWith(rel_path, filesep)
        rel_path = extractAfter(rel_path, filesep);
    end
    
    % Check if any part of the path starts with a '.' (e.g., .git/...)
    parts = strsplit(rel_path, filesep);
    if ~any(startsWith(parts, '.'))
        files_to_concatenate = [files_to_concatenate; listing(i)];
    end
end

if isempty(files_to_concatenate)
    fprintf('No .m files found in visible project directories.\n');
    return;
end

% --- CUSTOM SORTING: Ensure correct file order (Root files first, then subfolders by path) ---
files_to_sort = files_to_concatenate; 
% 1. Calculate the relative path for every file
relative_paths = cell(length(files_to_sort), 1);
for i = 1:length(files_to_sort)
    full_path_abs = fullfile(files_to_sort(i).folder, files_to_sort(i).name);
    
    % Get the path relative to the true project root for sorting
    rel_path = extractAfter(full_path_abs, search_root);
    if startsWith(rel_path, filesep)
        rel_path = extractAfter(rel_path, filesep);
    end
    
    % Add a special prefix to root files to force them to sort first
    if isempty(fileparts(rel_path))
        relative_paths{i} = ['!', rel_path]; 
    else
        relative_paths{i} = rel_path;
    end
end
% 2. Sort the files based on the relative path strings
[~, idx] = sort(relative_paths);
files_to_concatenate = files_to_sort(idx);
% --------------------------------------------------------------------------------------------

% 2. Open the output file for writing (will overwrite if it exists)
fileID = fopen(output_full_path, 'wt', 'n', 'UTF-8');
if fileID == -1
    error('Could not open file for writing: %s', output_full_path);
end

% 3. Process and print/write each file
fprintf('\n--- CONCATENATED CODE START ---\n\n');

% Write the global header to the file (only to file)
fprintf(fileID, '--- CONCATENATED CODE FROM PROJECT: %s ---\n\n', project_name);

for i = 1:length(files_to_concatenate)
    file_info = files_to_concatenate(i);
    
    full_path_abs = fullfile(file_info.folder, file_info.name);
    
    % Construct the desired 'FILE Path' using the dynamic project name and relative segment
    rel_path_segment = extractAfter(full_path_abs, search_root);
    if startsWith(rel_path_segment, filesep)
        rel_path_segment = extractAfter(rel_path_segment, filesep);
    end
    
    % The output path format is now: ProjectName/relative/path/to/file.m
    file_path_output = sprintf('%s/%s', project_name, rel_path_segment);
    
    % Read the content of the file
    file_content = fileread(full_path_abs);
    
    % --- Generate Custom Structured Header (USING 3 HASH SIGNS) ---
    header_start_line1 = sprintf('### START OF FILE: %s\n', file_info.name);
    header_start_line2 = sprintf('### FILE Path: %s\n', file_path_output);
    header_end = sprintf('### END OF FILE: %s\n\n', file_info.name);
    
    % Print structured output to Command Window
    fprintf(header_start_line1);
    fprintf(header_start_line2);
    fprintf('%s\n', file_content); 
    fprintf(header_end);
    
    % Write structured output to the text file
    fprintf(fileID, header_start_line1);
    fprintf(fileID, header_start_line2);
    fprintf(fileID, '%s\n', file_content);
    fprintf(fileID, header_end);
end

% 4. Close the file and finalize output
fclose(fileID);

fprintf('\n--- CONCATENATED CODE END ---\n');
fprintf('Content printed to terminal for immediate copy/paste.\n');
fprintf('A consolidated version has also been saved to: %s\n', output_full_path);
### END OF FILE: ConcatenateCode.m

### START OF FILE: GenerateProjectTree.m
### FILE Path: AutomationForExoskeleton/scripts/utils/GenerateProjectTree.m
%% GenerateProjectTree.m
% --------------------------------------------------------------------------
% FUNCTION: [] = GenerateProjectTree()
% PURPOSE: Recursively scans the project directory and prints the folder/file structure to project_tree.txt.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-12
% LAST MODIFIED: 2025-12-15 (Fixed path logic to be location-independent)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
%   - MATLAB built-in functions (dir, fprintf, diary, fileparts, mfilename, mkdir)
% --------------------------------------------------------------------------
% NOTES:
%   - This version automatically determines the project root by locating the 
%     'scripts/utils' folder (where this script resides) and navigating two 
%     levels up.
%   - The script will work correctly no matter where it is called from, as 
%     long as it remains in 'scripts/utils/'.
%   - Excludes hidden folders (starting with '.').
%   - Truncates massive raw data folders (>200 files) for readability.
%   - Output is saved to: [Project Root]/scripts/utils/project_tree.txt
% --------------------------------------------------------------------------

% --- Define Paths (Location-Independent Logic) ---

% 1. Get the full path to the currently running script (ConcatenateCode.m)
% Note: mfilename('fullpath') works if the file is on the path or run directly.
this_script_path = mfilename('fullpath');
if isempty(this_script_path)
    error('Could not determine script path. Ensure it is saved and on the MATLAB path.');
end

% 2. Determine the project root by traversing up two levels from the script's folder:
%    /scripts/utils/ConcatenateCode.m -> /scripts/utils/ -> /scripts/ -> /AutomationForExoskeleton/
output_dir = fileparts(this_script_path);    % Gets the /scripts/utils/ folder
scripts_dir = fileparts(output_dir);         % Gets the /scripts/ folder
project_root = fileparts(scripts_dir);       % Gets the /AutomationForExoskeleton/ folder (the true project root)

% 3. Define the output file path (output_dir is already /scripts/utils/)
output_filename = 'project_tree.txt';
output_full_path = fullfile(output_dir, output_filename);

% Ensure the output directory exists
if ~exist(output_dir, 'dir')
    mkdir(output_dir);
end
% ---------------------

% Line 1: Output only to Command Window (pre-execution message)
fprintf('Starting project structure generation...\n');

% 0. EXPLICIT OVERWRITE FIX: Delete the output file if it exists to guarantee a clean overwrite.
if exist(output_full_path, 'file')
    delete(output_full_path);
end

% 1. Start capturing the Command Window output to the specified file
diary(output_full_path);

try
    % Lines that are saved to the file:

    % Display the root name followed by '/'.
    [~, root_name, ~] = fileparts(project_root); % Get the name of the true project root
    fprintf('%s/\n', root_name);

    % 2. Start the recursive drawing process
    drawTreeLevel(project_root, ''); % Start scanning from the true project root
    
catch ME
    % Ensure diary is turned off even if an error occurs
    diary off;
    
    % Display error message to the console
    warning('An error occurred during script execution. Diary was turned off.');
    rethrow(ME);
end

% 3. Stop capturing the Command Window output
diary off;

% Line 2: Output only to Command Window (post-execution success message)
fprintf('\nScan completed and saved to %s.\n', output_full_path);

%% --- NESTED FUNCTION (The Recursive Logic) ---

function drawTreeLevel(current_path, prefix)
% Recursively draws the content of the current folder.

% 1. Get all entries (files and folders) in the current directory
listing = dir(current_path);

% 2. Filter system entries ('.', '..')
is_valid_entry = ~ismember({listing.name}, {'.', '..'});
entries = listing(is_valid_entry);

% 3. Filter hidden directories (starting with '.')
is_not_hidden = ~startsWith({entries.name}, '.');
entries = entries(is_not_hidden);

% 4. Split into subfolders and files, sort alphabetically
folders = entries([entries.isdir]);
files = entries(~[entries.isdir]);

[~, folder_idx] = sort({folders.name});
folders = folders(folder_idx);

[~, file_idx] = sort({files.name});
files = files(file_idx);

sorted_entries = [folders; files];

if isempty(sorted_entries)
    return;
end

N = length(sorted_entries);

% 5. Iterate and draw each entry
for i = 1:N
    entry = sorted_entries(i);
    is_last = (i == N);
    
    % --- Determine Connectors and Next Prefix Segment ---
    if is_last
        connector = '└── ';
        new_prefix_segment = '    '; 
    else
        connector = '├── ';
        new_prefix_segment = '│   '; 
    end
    
    % Build the full line to print
    name_suffix = entry.name;
    if entry.isdir
        name_suffix = [name_suffix, '/'];
    end
    
    fprintf('%s%s%s\n', prefix, connector, name_suffix);
    
    % 6. If the entry is a folder, recurse into it
    if entry.isdir
        new_path = fullfile(current_path, entry.name);
        new_prefix = [prefix, new_prefix_segment];

        % Truncation check for massive raw data folders (over 200 files)
        sub_listing = dir(new_path);
        sub_entries_count = length(sub_listing(~ismember({sub_listing.name}, {'.', '..'})));
        
        if sub_entries_count > 200 && contains(entry.name, 'raw', 'IgnoreCase', true)
            fprintf('%s%s%s\n', new_prefix, '└── ', '... (truncated: many raw data files)');
        else
            drawTreeLevel(new_path, new_prefix);
        end
    end
end
end
### END OF FILE: GenerateProjectTree.m

### START OF FILE: ImportData.m
### FILE Path: AutomationForExoskeleton/src/acquisition/ImportData.m
%% ImportData.m
% --------------------------------------------------------------------------
% FUNCTION: [back, hipL, hipR, annotations] = ImportData(activityName)
% PURPOSE: Implements the Data Acquisition Protocol, reading raw CSV data from 
% a specified activity folder (assuming a single IMU on the back).
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-11
% LAST MODIFIED: 2025-12-13 (Fixed dummy data sizing for hipL/hipR)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - process_imu_table (Nested function)
% --------------------------------------------------------------------------
% NOTES:
% - Assumes raw CSV files are named Accelerometer.csv, Gyroscope.csv, etc. 
% within the '../data/raw/<activityName>/' folder.
% - This function is currently adapted to load the *single* IMU data found in 
% the raw directory and assigns it to the 'back' sensor. 
% - 'hipL' and 'hipR' are returned as zero arrays for pipeline compatibility.
% --------------------------------------------------------------------------

function [back, hipL, hipR, annotations] = ImportData(activityName)
% Define path to the specific activity folder
baseDir = '../data/raw/';
activityPath = fullfile(baseDir, activityName);

% Filenames
fileAcc = fullfile(activityPath, 'Accelerometer.csv');
fileGyro = fullfile(activityPath, 'Gyroscope.csv');
fileAnnot = fullfile(activityPath, 'Annotation.csv'); % Includes ground truth labels

% Check files exist
if ~isfolder(activityPath)
error('Activity folder not found: %s', activityPath);
end
if ~isfile(fileAcc) || ~isfile(fileGyro)
error('IMU data files not found in: %s', activityPath);
end

% --- 1. Import Raw Tables ---
opts = detectImportOptions(fileAcc);
accTable = readtable(fileAcc, opts);

opts = detectImportOptions(fileGyro);
gyroTable = readtable(fileGyro, opts);

if isfile(fileAnnot)
opts = detectImportOptions(fileAnnot);
annotations = readtable(fileAnnot, opts);
else
warning('Annotation file not found. Returning empty table.');
annotations = table();
end

% --- 2. Process and Assign Data ---
back = process_imu_table(accTable, gyroTable);
N_samples = size(back.acc, 1);

% Fix: Create dummy zero data with correct N_samples size
hipL.acc = zeros(N_samples, 3);
hipL.gyro = zeros(N_samples, 3);
hipR.acc = zeros(N_samples, 3);
hipR.gyro = zeros(N_samples, 3);

fprintf('Imported %d samples of IMU data for activity "%s".\n', N_samples, activityName);
end

%% --- NESTED FUNCTION (Utility for Table Processing) ---
function imu = process_imu_table(accTable, gyroTable)
% Converts imported tables to standard IMU data structure (Nx3 arrays).

% Error checking for missing data (as dummy creation is now handled by the caller)
if isempty(accTable) || isempty(gyroTable)
    error('process_imu_table: Called without data. Data loading failed.');
end

imu.acc = table2array(accTable);
imu.gyro = table2array(gyroTable);
end
### END OF FILE: ImportData.m

### START OF FILE: PrepareTrainingData.m
### FILE Path: AutomationForExoskeleton/src/acquisition/PrepareTrainingData.m
%% PrepareTrainingData.m
% --------------------------------------------------------------------------
% FUNCTION: [features, labels_binary, ModelMetadata] = PrepareTrainingData(cfg)
% PURPOSE: Loads data, extracts features in sliding windows, and binarizes 
% the labels for binary SVM training (WALKING=1, STANDING=0).
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Added ModelMetadata output)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - ExoConfig.m
% - LoadUSCHAD.m (to ensure data is processed)
% - ImportUschadSingleImu.m
% - Features.m
% --------------------------------------------------------------------------

function [features, labels_binary, ModelMetadata] = PrepareTrainingData(cfg)

if nargin < 1
    cfg = ExoConfig();
end

% --- 1. Load USC-HAD Data Structure ---
% NOTE: Assuming LoadUSCHAD has been run and usc_had_dataset.mat exists
load(cfg.FILE.USCHAD_DATA, 'usc');

% Prepare lists for feature vectors and corresponding binary labels
features = [];
labels_binary = [];
all_trial_names = fieldnames(usc);

fprintf('Starting feature extraction on %d USC-HAD trials...\n', length(all_trial_names));

% --- 2. Iterate through all trials ---
for i = 1:length(all_trial_names)
    trial_name = all_trial_names{i};
    trial = usc.(trial_name);
    
    % Use only the 'back' IMU data (single IMU pipeline simulation)
    acc = trial.acc;
    gyro = trial.gyro;
    raw_label = trial.label;
    
    n_samples = size(acc, 1);
    
    % Binarize the single trial label
    is_walking = ismember(raw_label, cfg.DS.USCHAD.WALKING_LABELS);
    trial_label_binary = double(is_walking);

    % --- Sliding Window Feature Extraction ---
    for k = 1:cfg.STEP_SIZE:(n_samples - cfg.WINDOW_SIZE + 1)
        window_start = k;
        window_end = k + cfg.WINDOW_SIZE - 1;
        
        windowAcc = acc(window_start:window_end, :);
        windowGyro = gyro(window_start:window_end, :);

        % Extract Features (pass both Accel and Gyro)
        feature_vector = Features(windowAcc, windowGyro, cfg.FS);
        
        features = [features; feature_vector]; %#ok<AGROW>
        labels_binary = [labels_binary; trial_label_binary]; %#ok<AGROW>
    end
end

% --- 3. Prepare Metadata ---
ModelMetadata.fs = cfg.FS;
ModelMetadata.windowSize = cfg.WINDOW_SIZE;
ModelMetadata.stepSize = cfg.STEP_SIZE;
% Fix: Save the raw multi-class labels used for binarization (CRITICAL for evaluation scripts)
ModelMetadata.WALKING_LABELS_RAW = cfg.DS.USCHAD.WALKING_LABELS; 
ModelMetadata.NON_WALKING_LABELS_RAW = cfg.DS.USCHAD.NON_WALKING_LABELS;

fprintf('Feature extraction complete. Total %d windows generated.\n', size(features, 1));
end
### END OF FILE: PrepareTrainingData.m

### START OF FILE: Classifier.m
### FILE Path: AutomationForExoskeleton/src/classification/Classifier.m
%% Classifier.m
% --------------------------------------------------------------------------
% FUNCTION: [performance] = EvaluateClassifier(test_trial_name)
% PURPOSE: Loads a trained SVM and tests its performance on a specific, 
% held-out single trial from the USC-HAD dataset.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Fixed label handling/binarization)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - ExoConfig.m
% - ImportUschadSingleImu.m
% - Features.m
% --------------------------------------------------------------------------
% NOTES:
% - Calculates window-by-window classification accuracy.
% --------------------------------------------------------------------------

function [performance] = Classifier(test_trial_name)

clc;
cfg = ExoConfig();

% --- 0. Pre-Flight Check ---
model_path = cfg.FILE.SVM_MODEL;
if ~exist(model_path, 'file')
error('Trained SVM Model not found. Please run TrainSvmBinary first.');
end

% --- 1. Load Trained Model and Metadata ---
loaded = load(model_path, 'SVMModel', 'ModelMetadata');
SVMModel = loaded.SVMModel;
ModelMetadata = loaded.ModelMetadata;

FS = ModelMetadata.fs;
WINDOW_SIZE = ModelMetadata.windowSize;
STEP_SIZE = ModelMetadata.stepSize;

fprintf('--- Starting Classifier Evaluation ---\n');
fprintf('Testing on trial: %s (FS: %d Hz)\n', test_trial_name, FS);

% --- 2. Load Test Data and Determine Ground Truth ---
try
% Fix: Corrected function signature call (returns 3 IMU structs)
[back, ~, ~] = ImportUschadSingleImu(test_trial_name); 

% Load the USC structure to get the activity ID for the test trial
loaded_usc = load(cfg.FILE.USCHAD_DATA, 'usc');
raw_activity_id = loaded_usc.usc.(test_trial_name).label;

n_total_samples = size(back.acc, 1);

% Fix: Binarize the ground truth label based on the ModelMetadata
if ismember(raw_activity_id, ModelMetadata.WALKING_LABELS_RAW)
    ground_truth_binary = cfg.STATE_WALKING; % 1
else
    ground_truth_binary = cfg.STATE_STANDING; % 0
end

% Create a ground truth label for every *window*
n_windows = floor((n_total_samples - ModelMetadata.windowSize) / ModelMetadata.stepSize) + 1;
ground_truth_windows = repmat(ground_truth_binary, n_windows, 1);

catch ME
error('Data loading or ground truth determination failed: %s', ME.message);
end

% --- 3. Extract Features for Test Data ---
test_features = [];
window_labels = []; % Store the predicted label for each window

for k = 1:STEP_SIZE:(n_total_samples - WINDOW_SIZE + 1)
    window_start = k;
    window_end = k + WINDOW_SIZE - 1;

    windowAcc = back.acc(window_start:window_end, :);
    windowGyro = back.gyro(window_start:window_end, :); % Include Gyro

    feature_vector = Features(windowAcc, windowGyro, FS);
    test_features = [test_features; feature_vector]; %#ok<AGROW>
end

% --- 4. Classify All Windows ---
predicted_labels = predict(SVMModel, test_features);


% --- 5. Performance Evaluation (Window-by-Window) ---
TP = sum(ground_truth_windows == 1 & predicted_labels == 1);
TN = sum(ground_truth_windows == 0 & predicted_labels == 0);
FP = sum(ground_truth_windows == 0 & predicted_labels == 1);
FN = sum(ground_truth_windows == 1 & predicted_labels == 0);

Accuracy = (TP + TN) / (TP + TN + FP + FN);
Precision = TP / (TP + FP); 
Recall = TP / (TP + FN); 
Specificity = TN / (TN + FP);

performance.TP = TP;
performance.TN = TN;
performance.FP = FP;
performance.FN = FN;
performance.Accuracy = Accuracy;
performance.Precision = Precision;
performance.Recall = Recall;
performance.Specificity = Specificity;

% --- 6. Report Results ---
fprintf('\n--- Classification Performance Summary (Window-by-Window) ---\n');
fprintf('Target Label: %d (WALK=%d, STAND=%d)\n', ground_truth_binary, cfg.STATE_WALKING, cfg.STATE_STANDING);
fprintf('Total Windows: %d\n', n_windows);
fprintf('------------------------------------------\n');
fprintf('Accuracy: %.2f%%\n', Accuracy * 100);
fprintf('Precision: %.2f%%\n', Precision * 100);
fprintf('Recall: %.2f%%\n', Recall * 100);
fprintf('------------------------------------------\n');

end
### END OF FILE: Classifier.m

### START OF FILE: RealtimeFsm.m
### FILE Path: AutomationForExoskeleton/src/classification/RealtimeFsm.m
%% RealtimeFsm.m
% --------------------------------------------------------------------------
% FUNCTION: [command, new_state] = RealtimeFsm(classified_label, current_state)
% PURPOSE: Implements a simple Finite State Machine (FSM) to transition
% the exoskeleton control state based on the SVM classification output.
% It prevents rapid, noisy switching between STANDING (0) and WALKING (1).
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Initial implementation)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - ExoConfig.m (Requires constants for state definitions)
% --------------------------------------------------------------------------
% NOTES:
% - State 0: STANDING/NON-LOCOMOTION
% - State 1: WALKING/LOCOMOTION
% - COMMAND is the output signal for the exoskeleton actuators (0 or 1).
% --------------------------------------------------------------------------

function [command, new_state] = RealtimeFsm(classified_label, current_state)

% Load Configuration for State Constants
cfg = ExoConfig();
STATE_STANDING = cfg.STATE_STANDING; % Should be 0
STATE_WALKING = cfg.STATE_WALKING;   % Should be 1

% --- FSM Parameters (Adjust these for sensitivity/latency trade-off) ---
% The number of consecutive WALKING predictions required to transition from STANDING to WALKING.
WALK_ENTRY_THRESHOLD = 3; 
% The number of consecutive STANDING predictions required to transition from WALKING to STANDING.
STAND_EXIT_THRESHOLD = 5; 

persistent walk_counter stand_counter;

% Initialize counters on first call
if isempty(walk_counter) || isempty(stand_counter)
    walk_counter = 0;
    stand_counter = 0;
end

% --- 1. Update Transition Counters ---

if classified_label == STATE_WALKING
    walk_counter = walk_counter + 1;
    stand_counter = 0; % Reset opposing counter
else % classified_label == STATE_STANDING
    stand_counter = stand_counter + 1;
    walk_counter = 0; % Reset opposing counter
end


% --- 2. State Transition Logic ---

new_state = current_state; % Assume state remains the same

switch current_state
    case STATE_STANDING
        % Current State: STANDING (0)
        
        % Check for transition to WALKING
        if walk_counter >= WALK_ENTRY_THRESHOLD
            new_state = STATE_WALKING;
            % Reset counter for the new state's exit condition
            stand_counter = 0; 
            fprintf('FSM Transition: STANDING -> WALKING\n');
        end
        
    case STATE_WALKING
        % Current State: WALKING (1)
        
        % Check for transition back to STANDING
        if stand_counter >= STAND_EXIT_THRESHOLD
            new_state = STATE_STANDING;
            % Reset counter for the new state's exit condition
            walk_counter = 0;
            fprintf('FSM Transition: WALKING -> STANDING\n');
        end
        
    otherwise
        % Handle unexpected state (should not happen)
        warning('FSM received an unexpected current state: %d. Defaulting to STANDING.', current_state);
        new_state = STATE_STANDING;
        
end


% --- 3. Generate Control Command ---

% The control command is typically the new state itself, representing 
% whether the exoskeleton should be providing locomotion assistance (1) or 
% locked/idle (0).
command = new_state;

end
### END OF FILE: RealtimeFsm.m

### START OF FILE: StateEstimator.m
### FILE Path: AutomationForExoskeleton/src/classification/StateEstimator.m
%% StateEstimator.m
% --------------------------------------------------------------------------
% FUNCTION: [command, state] = updateFSM(new_label, current_state)
% PURPOSE: Implements the Finite State Machine (FSM) to manage transitions between locomotion modes and generate exoskeleton control commands.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-11
% LAST MODIFIED: 2025-12-13
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - None (Self-contained logic)
% --------------------------------------------------------------------------
% NOTES:
% - State smoothing: requires 3 consecutive labels to confirm a state change.
% - The output `command` is a simple low-level signal (e.g., 0=stand, 1=walk gait).
% --------------------------------------------------------------------------

function [command, next_state] = StateEstimator(new_label, current_state)

% --- Configuration Parameters ---
persistent state_counter % Persist across calls to track consecutive labels
if isempty(state_counter)
    state_counter = 0; % 0: Consecutive label counter
end

% Required consecutive labels to confirm a state transition
CONFIRMATION_THRESHOLD = 3; 

% --- State Definitions ---
% Use descriptive integer codes
STATE_STANDING = 0;
STATE_WALKING = 1;

% Assuming new_label comes from SVM (0=Stand, 1=Walk)

% Initialize next state and command to current values
next_state = current_state;
command = current_state; % Command is typically the same as the final state

% ----------------------------------------------------------------
% 1. CHECK FOR CONSISTENCY (Smoothing)
% ----------------------------------------------------------------

if new_label == next_state
    % Label matches current state, reset counter
    state_counter = 0;
    return; % No state change needed
end

% ----------------------------------------------------------------
% 2. CHECK FOR TRANSITION
% ----------------------------------------------------------------

if new_label ~= next_state
    % Label suggests a change; increment counter
    state_counter = state_counter + 1;

    if state_counter >= CONFIRMATION_THRESHOLD
        % Threshold reached: Execute the transition
        
        if current_state == STATE_STANDING && new_label == STATE_WALKING
            % Transition: STANDING -> WALKING
            next_state = STATE_WALKING;
            command = 1; % Low-level command to initiate walking gait
            fprintf('FSM Transition: STANDING -> WALKING\n');

        elseif current_state == STATE_WALKING && new_label == STATE_STANDING
            % Transition: WALKING -> STANDING
            next_state = STATE_STANDING;
            command = 0; % Low-level command to lock/stop exoskeleton
            fprintf('FSM Transition: WALKING -> STANDING\n');
        end

        % Reset counter after successful transition
        state_counter = 0;
    end
end

% If the threshold was not reached, next_state remains current_state
end
### END OF FILE: StateEstimator.m

### START OF FILE: Features.m
### FILE Path: AutomationForExoskeleton/src/features/Features.m
%% Features.m
% --------------------------------------------------------------------------
% FUNCTION: [features_out] = Features(windowAcc, windowGyro, Fs)
% PURPOSE: Calculates time-domain and frequency-domain features from IMU data windows for use in the locomotion classifier.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-11
% LAST MODIFIED: 2025-12-14 (Header fix)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - MATLAB built-in functions (fft, abs, mean, var, max)
% --------------------------------------------------------------------------
% NOTES:
% - Calculates mean/variance of acceleration magnitude and the dominant frequency.
% - Dominant frequency is crucial for distinguishing steady-state walking (1-2 Hz).
% - Currently ignores windowGyro input (~).
% --------------------------------------------------------------------------

function [features_out] = Features(windowAcc, ~, Fs)

% 1. Time-Domain Features (Used in TrainSvmBinary.m)
% Calculate magnitude of acceleration vector (net force)
mag_acc = sqrt(sum(windowAcc.^2, 2));

% Feature 1: Mean of Acceleration Magnitude
feat_mean_mag = mean(mag_acc);

% Feature 2: Variance of Acceleration Magnitude
feat_var_mag = var(mag_acc);


% 2. Frequency-Domain Features
N = length(windowAcc);
if N < 2
% Handle edge case of very small window
features_out = [feat_mean_mag, feat_var_mag, 0];
return; 
end

% Perform Fast Fourier Transform (FFT) on the raw Z-axis of acceleration
% Z-axis (vertical/gravity) often has the clearest gait signature
acc_z = windowAcc(:, 3); % Assuming Z is the 3rd column

Y = fft(acc_z);
P2 = abs(Y/N);
P1 = P2(1:floor(N/2)+1); % Single-sided spectrum
P1(2:end-1) = 2*P1(2:end-1);

% Frequency vector
f = Fs*(0:floor(N/2))/N;

% Feature 3: Dominant Frequency (excluding DC component at f(1)=0)
[~, idx] = max(P1(2:end)); % Find peak amplitude index, starting from index 2
feat_dom_freq = f(idx + 1); % Adjust index back to frequency vector f

% 3. Output
% Combine all features into a single row vector
features_out = [feat_mean_mag, feat_var_mag, feat_dom_freq];

end
### END OF FILE: Features.m

### START OF FILE: FusionKalman.m
### FILE Path: AutomationForExoskeleton/src/fusion/FusionKalman.m
%% FusionKalman.m
% --------------------------------------------------------------------------
% FUNCTION: [fuse_back, fuse_hipL] = initializeFilters(Fs)
% FUNCTION: [hipFlexionAngle] = estimateAngle(orientBack, orientHipL)
% PURPOSE: Provides configuration and helper functions for the Kalman Filter 
%          used for sensor fusion (Accel/Gyro) to estimate joint angles.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-11
% LAST MODIFIED: 2025-12-14 (Refactored to provide modular filter objects)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - MATLAB Sensor Fusion Toolbox (imufilter, quat2eul)
% --------------------------------------------------------------------------
% NOTES:
% - The filter objects must be initialized once and updated incrementally 
%   by the main pipeline script.
% - Tuning parameters are defined here to achieve the desired RMSE.
% --------------------------------------------------------------------------

function [fuse_back, fuse_hipL] = initializeFilters(Fs)
% Initializes two independent IMU filter objects (one for the back, one for the hip).

% Tuning parameters (optimized for exoskeleton kinematics)
ACCEL_NOISE = 0.01; 
GYRO_NOISE = 0.005;

fprintf('Initializing Kalman IMU Filters (SampleRate: %d Hz)...\n', Fs);

% Initialize filter for the Back IMU
fuse_back = imufilter('SampleRate', Fs, ...
    'AccelerometerNoise', ACCEL_NOISE, ...
    'GyroscopeNoise', GYRO_NOISE, ...
    'ReferenceFrame', 'ENU'); % East-North-Up reference frame

% Initialize filter for the Left Hip IMU
fuse_hipL = imufilter('SampleRate', Fs, ...
    'AccelerometerNoise', ACCEL_NOISE, ...
    'GyroscopeNoise', GYRO_NOISE, ...
    'ReferenceFrame', 'ENU'); 

end


function hipFlexionAngle = estimateAngle(orientBack, orientHipL)
% Computes the relative joint angle (Left Hip Flexion) from the two quaternion orientations.
% This function is called once per time step in the real-time loop.

% Convert orientation quaternions to Euler angles (ZYX sequence: Yaw-Pitch-Roll)
% Pitch (Y-axis, index 2) typically represents the sagittal plane rotation (flexion/extension)
eulBack = quat2eul(orientBack, 'ZYX'); % [Yaw, Pitch, Roll]
eulHipL = quat2eul(orientHipL, 'ZYX');

% Hip Flexion Angle is the difference in Pitch angle between the two segments
% Convert from radians to degrees
hipFlexionAngle = (eulHipL(2) - eulBack(2)) * (180/pi); 

end

% --- Original Helper Function kept for general IMU data validation ---

function validateIMUData(data, label)
% Checks if the required IMU fields are present and correctly sized.
requiredFields = {'acc', 'gyro'};
for f = requiredFields
if ~isfield(data, f{1}) || size(data.(f{1}), 2) ~= 3
error('%s IMU data missing or invalid: %s field.', label, f{1});
end
end
if size(data.acc, 1) ~= size(data.gyro, 1)
error('%s IMU data size mismatch between acc and gyro.', label);
end
end
### END OF FILE: FusionKalman.m

### START OF FILE: acquisition_test.m
### FILE Path: AutomationForExoskeleton/tests/acquisition_test.m

### END OF FILE: acquisition_test.m

### START OF FILE: classification_test.m
### FILE Path: AutomationForExoskeleton/tests/classification_test.m

### END OF FILE: classification_test.m

