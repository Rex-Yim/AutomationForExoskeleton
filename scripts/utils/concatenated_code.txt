--- CONCATENATED CODE FROM PROJECT: AutomationForExoskeleton ---

### START OF FILE: ExoConfig.m
### FILE Path: AutomationForExoskeleton/config/ExoConfig.m
%% ExoConfig.m
% --------------------------------------------------------------------------
% PURPOSE: Defines all global configuration parameters, constants, and 
% hyperparameters for the exoskeleton control pipeline.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Updated USC-HAD labels)
% --------------------------------------------------------------------------
% NOTES:
% - Edit this file to tune the system (e.g., Fs, window size, Kalman noise).
% - All other scripts should load these variables using a function call.
% --------------------------------------------------------------------------

function cfg = ExoConfig()
% --- General System Parameters ---
cfg.FS = 100; % Sample Rate (Hz) - Matches USC-HAD
cfg.ACTIVITY_SIMULATION = 'walking_straight'; % Default raw folder for pipeline simulation
% --- Classification Parameters (Locomotion Mode) ---
cfg.WINDOW_SIZE_S = 1.0; % Window duration in seconds
cfg.STEP_SIZE_S = 0.5; % Step duration in seconds (50% overlap)
cfg.WINDOW_SIZE = round(cfg.WINDOW_SIZE_S * cfg.FS);
cfg.STEP_SIZE = round(cfg.STEP_SIZE_S * cfg.FS);
% SVM Model Parameters
cfg.SVM_KERNEL = 'rbf';
cfg.SVM_STANDARDIZE = true;
% FSM Parameters
cfg.FSM_CONFIRMATION_THRESHOLD = 3; % Consecutive labels required for state change
cfg.STATE_STANDING = 0;
cfg.STATE_WALKING = 1;
% Dataset Specific Labels (USC-HAD)
% Fix: Expanded labels to cover all activities (1-6 locomotion, 7-12 non-locomotion)
cfg.DS.USCHAD.WALKING_LABELS = [1, 2, 3, 4, 5, 6]; % WalkForward, WalkLeft, WalkRight, Upstairs, Downstairs, RunForward
cfg.DS.USCHAD.NON_WALKING_LABELS = [7, 8, 9, 10, 11, 12]; % Jump, Sit, Stand, Sleep, ElevatorUp, ElevatorDown
% --- Sensor Fusion Parameters (Kalman Filter) ---
% Tuning parameters to achieve RMSE < 5 deg
cfg.KALMAN.ACCEL_NOISE = 0.01; 
cfg.KALMAN.GYRO_NOISE = 0.005;
% --- File Paths & Names ---
cfg.FILE.SVM_MODEL = 'results/Binary_SVM_Model.mat';
cfg.FILE.USCHAD_DATA = 'data/public/USC-HAD/usc_had_dataset.mat';
% CRITICAL FIX: Added the missing configuration variable for the raw data folder
cfg.FILE.USCHAD_FOLDER = 'data/public/USC-HAD/USC-HAD_raw';
cfg.FILE.HUGADB_DATA = 'data/public/HuGaDB/hugadb_dataset.mat';
end
### END OF FILE: ExoConfig.m

### START OF FILE: LoadHuGaDB.m
### FILE Path: AutomationForExoskeleton/data/public/HuGaDB/LoadHuGaDB.m
%% LoadHuGaDB.m
% --------------------------------------------------------------------------
% FUNCTION: [] = LoadHuGaDB()
% PURPOSE: Loads all raw HuGaDB text files, parses the data, and saves it 
%          to a single .mat file, structured for use with the project's 
%          three-IMU (Back, HipL, HipR) pipeline convention.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-12
% LAST MODIFIED: 2025-12-14 (Restructured output for pipeline compatibility)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - dlmread (MATLAB built-in)
% --------------------------------------------------------------------------
% NOTES:
% - HuGaDB Sensor Mapping:
%   - Project's HipL -> HuGaDB Left Thigh (lt)
%   - Project's HipR -> HuGaDB Right Thigh (rt)
%   - Project's Back -> Dummy zeros (HuGaDB lacks a dedicated back sensor)
% --------------------------------------------------------------------------

clear; clc;

dataDir = 'HuGaDB_v2_raw'; % Path to .txt files
outputFile = 'hugadb_dataset.mat';

files = dir(fullfile(dataDir, '*.txt'));
hugadb_data = struct(); % Store all sessions

if isempty(files)
    error('No raw HuGaDB .txt files found in %s.', dataDir);
end

fprintf('Loading and restructuring %d HuGaDB trials...\n', length(files));

% Activity ID to Name mapping (simplified example for HuGaDB)
% Labels in HuGaDB are: 1=Sit, 2=Stand, 3=SitToStand, 4=StandToSit, 5=Walk, 6=StairsUp, 7=StairsDown, 8=Run
activityNames = {'Sit', 'Stand', 'SitToStand', 'StandToSit', 'Walk', 'StairsUp', 'StairsDown', 'Run'};

for i = 1:length(files)
    filePath = fullfile(dataDir, files(i).name);
    % Skips 4 header lines using dlmread
    rawMatrix = dlmread(filePath, '\t', 4, 0); 

    % --- 1. Parse Raw Data (Column indices based on standard HuGaDB format) ---
    
    % Data for Hip L (using Left Thigh IMU)
    data.hipL.acc = rawMatrix(:, 31:33); % Left thigh accel
    data.hipL.gyro = rawMatrix(:, 34:36); % Left thigh gyro

    % Data for Hip R (using Right Thigh IMU)
    data.hipR.acc = rawMatrix(:, 13:15); % Right thigh accel
    data.hipR.gyro = rawMatrix(:, 16:18); % Right thigh gyro

    % Data for Back (Dummy zero data to satisfy pipeline input)
    data.back.acc = zeros(size(data.hipL.acc));
    data.back.gyro = zeros(size(data.hipL.gyro));

    % Activity label and Metadata
    label = rawMatrix(:, 39); % Activity label
    data.label = label(1); % Use the first label as the trial label (assuming single activity per file)
    data.activityName = activityNames{data.label};
    data.fs = 100; % Assuming 100 Hz for HuGaDB (common rate)
    
    % Store the full label vector separately if needed for time-series analysis
    data.labels_full = label; 
    
    % --- 2. Store in Main Structure ---
    sessionID = files(i).name(1:end-4); % e.g., 'HuGaDB_v2_various_01_00'
    hugadb_data.(sessionID) = data;
end

save(outputFile, 'hugadb_data', '-v7.3');
fprintf('HuGaDB saved as %s (%d trials) with pipeline-compatible structure.\n', outputFile, length(files));
### END OF FILE: LoadHuGaDB.m

### START OF FILE: ImportUschadSingleImu.m
### FILE Path: AutomationForExoskeleton/data/public/USC-HAD/ImportUschadSingleImu.m
%% ImportUschadSingleImu.m
% --------------------------------------------------------------------------
% FUNCTION: [back, hipL, hipR] = import_uschad_for_pipeline(trialFieldName)
% PURPOSE: Adapts the single-IMU USC-HAD data format to match the project's three-IMU pipeline, assigning the real data to the 'back' sensor.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-12
% LAST MODIFIED: 2025-12-12
% --------------------------------------------------------------------------
% DEPENDENCIES: 
%   - usc_had_dataset.mat
% --------------------------------------------------------------------------
% NOTES:
%   - `hipL` and `hipR` are returned as dummy zero arrays to satisfy pipeline function signatures.
%   - Used for pipeline validation when only one IMU is required.
% --------------------------------------------------------------------------

function [back, hipL, hipR] = ImportUschadSingleImu(trialFieldName)

load('data/public/USC-HAD/usc_had_dataset.mat', 'usc');

trial = usc.(trialFieldName);

back.acc  = trial.acc;
back.gyro = trial.gyro;

% Dummy placeholders (your Kalman/SVM only uses back for many tests anyway)
hipL.acc  = zeros(size(back.acc));
hipL.gyro = zeros(size(back.gyro));
hipR.acc  = zeros(size(back.acc));
hipR.gyro = zeros(size(back.gyro));

fprintf('Loaded USC-HAD trial %s → back sensor (label = %d: %s)\n', ...
        trialFieldName, trial.label, trial.activityName);
end
### END OF FILE: ImportUschadSingleImu.m

### START OF FILE: LoadUSCHAD.m
### FILE Path: AutomationForExoskeleton/data/public/USC-HAD/LoadUSCHAD.m
%% LoadUSCHAD.m
% --------------------------------------------------------------------------
% FUNCTION: usc = LoadUSCHAD(rawDir)
% PURPOSE: Loads all raw USC-HAD .mat files (recursively from subfolders),
%          normalizes the structure, and saves all trials into a single
%          usc_had_dataset.mat file.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-12
% LAST MODIFIED: 2025-12-16 (Fixed for sensor_readings, units, regex; extract subj from folder)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - MATLAB built-in functions (dir, load, regexp)
% --------------------------------------------------------------------------
% NOTES:
% - Extracts from 'sensor_readings' (Nx6: acc_xyz, gyro_xyz).
% - Converts units: acc g→m/s², gyro dps→rad/s.
% - Filenames: a<act>t<trial>.mat (no _); subj from folder.
% - Recursively searches subfolders (e.g., SubjectX/) for .mat files.
% - Call without arguments to use default path.
% --------------------------------------------------------------------------

function usc = LoadUSCHAD(rawDir)
    if nargin < 1
        rawDir = fullfile('USC-HAD_raw');
    end

    if ~isfolder(rawDir)
        error('USC-HAD raw folder not found: %s', rawDir);
    end

    % Recursive search for all .mat files in subfolders
    files = dir(fullfile(rawDir, '**/*.mat')); % '**' enables recursive search

    if isempty(files)
        error('No raw USC-HAD .mat files found in %s or its subfolders.', rawDir);
    end

    usc = struct();
    activityNames = {'WalkForward','WalkLeft','WalkRight','GoUpstairs',...
                     'GoDownstairs','RunForward','Jump','Sit','Stand',...
                     'Sleep','ElevatorUp','ElevatorDown'};

    fprintf('Loading %d USC-HAD trials...\n', length(files));
    skipped = 0;

    for i = 1:length(files)
        % Construct full filepath
        filepath = fullfile(files(i).folder, files(i).name);
        tmp = load(filepath);

        % --- Extract Sensor Data ---
        if isfield(tmp, 'sensor_readings')
            readings = tmp.sensor_readings;
            
            % Assume Nx6: columns 1-3 acc (g), 4-6 gyro (dps)
            % Check size and orient as Nx3
            if size(readings, 2) == 6  % Standard case
                acc = readings(:, 1:3);  % Nx3
                gyro = readings(:, 4:6); % Nx3
            elseif size(readings, 2) == 7  % If time column (col 1)
                acc = readings(:, 2:4);
                gyro = readings(:, 5:7);
            else
                warning('Skipping file %s: Unexpected sensor_readings size (%dx%d).', files(i).name, size(readings));
                skipped = skipped + 1;
                continue;
            end
            
            % If data is transposed (unlikely)
            if size(acc, 1) < size(acc, 2)
                acc = acc';
                gyro = gyro';
            end
            
            % Unit conversions
            acc = acc * 9.80665;      % g → m/s²
            gyro = deg2rad(gyro);     % dps → rad/s
        else
            warning('Skipping file %s: Missing ''sensor_readings'' field.', files(i).name);
            skipped = skipped + 1;
            continue;
        end

        % --- Parse Filename and Folder ---
        % Filename: a<act>t<trial>.mat (no underscores)
        tokens = regexp(files(i).name, 'a(?<act>\d+)t(?<trial>\d+)', 'names');
        if isempty(tokens)
            warning('Skipping invalid filename: %s', files(i).name);
            skipped = skipped + 1;
            continue;
        end

        % Extract subject from folder (e.g., 'Subject3' → subj=3)
        folder_tokens = regexp(files(i).folder, 'Subject(?<subj>\d+)', 'names');
        if isempty(folder_tokens)
            warning('Skipping file %s: Unable to parse subject from folder %s.', files(i).name, files(i).folder);
            skipped = skipped + 1;
            continue;
        end

        act = str2double(tokens.act);
        trial = str2double(tokens.trial);
        subj = str2double(folder_tokens.subj);

        usc_field = sprintf('s%s_a%s_t%s', num2str(subj), tokens.act, tokens.trial);

        % Store in usc struct
        usc.(usc_field).acc = acc;
        usc.(usc_field).gyro = gyro;
        usc.(usc_field).label = act;
        usc.(usc_field).activityName = activityNames{act};
        usc.(usc_field).fs = 100;  % USC-HAD is 100 Hz
    end

    outputFile = 'usc_had_dataset.mat';
    save(outputFile, 'usc', '-v7.3');
    fprintf('USC-HAD saved as %s (%d trials loaded, %d skipped).\n', outputFile, length(files) - skipped, skipped);
end
### END OF FILE: LoadUSCHAD.m

### START OF FILE: displayData_acc.m
### FILE Path: AutomationForExoskeleton/data/public/USC-HAD/displayData_acc.m
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Author: Mi Zhang
%Date: July, 2010
%File Name: displayData_acc.m
%Description: Visualize the 3-axis accelerometer data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Fs = 100;               % Sampling frequency = 100Hz

% Read the data
data = sensor_readings;
acc_x = data(: ,1);
acc_y = data(: ,2);
acc_z = data(: ,3);

% Parameter declaration
BIN_COUNT = 10;         % 
T = 1/Fs;               % 
Interval = 1000 / Fs;   %
L = size(acc_x, 1);     % 
t = (0:L-1)*T;          %

% Visualize the time series, histogram, and FFT
figure;
% Time series
subplot(3, 3, 1);
plot(t, acc_x);
grid on;
xlabel('Time (s)');
ylabel('Acceleration (g)');
title('X-Axis Data');

% Histogram
subplot(3, 3, 2);
hist(acc_x, BIN_COUNT);
grid on;
xlabel('Acceleration (g)');
ylabel('Count');
title('X-Axis Distribution');

% Spectral analysis
subplot(3, 3, 3);
NFFT = 2^nextpow2(L);               
Y = fft(acc_x, NFFT)/L;
f = Fs/2*linspace(0,1,NFFT/2+1);
plot(f,2*abs(Y(1:NFFT/2+1)));
title('X-Axis Spectrum');
xlabel('Frequency (Hz)');
ylabel('|X(f)|');

% Time series
subplot(3, 3, 4);
plot(t, acc_y);
grid on;
xlabel('Time (s)');
ylabel('Acceleration (g)');
title('Y-Axis Data');

% Histogram
subplot(3, 3, 5);
hist(acc_y, BIN_COUNT);
grid on;
xlabel('Acceleration (g)');
ylabel('Count');
title('Y-Axis Distribution');

% Spectral analysis
subplot(3, 3, 6);
NFFT = 2^nextpow2(L);              
Y = fft(acc_y, NFFT)/L;
f = Fs/2*linspace(0,1,NFFT/2+1);
plot(f,2*abs(Y(1:NFFT/2+1)));
title('Y-Axis Spectrum');
xlabel('Frequency (Hz)');
ylabel('|Y(f)|');

% Time series
subplot(3, 3, 7);
plot(t, acc_z);
grid on;
xlabel('Time (s)');
ylabel('Acceleration (g)');
title('Z-Axis Data');

% Histogram
subplot(3, 3, 8);
hist(acc_z, BIN_COUNT);
grid on;
xlabel('Acceleration (g)');
ylabel('Count');
title('Z-Axis Distribution');

% Spectral analysis
subplot(3, 3, 9);
NFFT = 2^nextpow2(L);               
Y = fft(acc_z, NFFT)/L;
f = Fs/2*linspace(0,1,NFFT/2+1);
plot(f,2*abs(Y(1:NFFT/2+1)));
title('Z-Axis Spectrum');
xlabel('Frequency (Hz)');
ylabel('|Z(f)|');



### END OF FILE: displayData_acc.m

### START OF FILE: displayData_gyro.m
### FILE Path: AutomationForExoskeleton/data/public/USC-HAD/displayData_gyro.m
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Author: Mi Zhang
%Date: July, 2010
%File Name: displayData_gyro.m
%Description: Visualize the 3-axis gyroscope data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Fs = 100;               % Sampling frequency = 100Hz

% Read the data
data = sensor_readings;
gyro_x = data(: ,4);
gyro_y = data(: ,5);
gyro_z = data(: ,6);

% Parameter declaration
BIN_COUNT = 10;         % 
T = 1/Fs;               % 
Interval = 1000 / Fs;   %
L = size(acc_x, 1);     % 
t = (0:L-1)*T;          %

% Visualize the time series, histogram, and FFT
figure;
% Time series
subplot(3, 3, 1);
plot(t, gyro_x);
grid on;
xlabel('Time (s)');
ylabel('Gyro (dps)');
title('X-Axis Gyro Data');

% Histogram
subplot(3, 3, 2);
hist(gyro_x, BIN_COUNT);
grid on;
xlabel('Gyro (dps)');
ylabel('Count');
title('X-Axis Gyro Distribution');

% Spectral analysis
subplot(3, 3, 3);
NFFT = 2^nextpow2(L);               
Y = fft(gyro_x, NFFT)/L;
f = Fs/2*linspace(0,1,NFFT/2+1);
plot(f,2*abs(Y(1:NFFT/2+1)));
title('X-Axis Gyro Spectrum');
xlabel('Frequency (Hz)');
ylabel('|Y(f)|');

% Time series
subplot(3, 3, 4);
plot(t, gyro_y);
grid on;
xlabel('Time (s)');
ylabel('Gyro (dps)');
title('Y-Axis Gyro Data');

% Histogram
subplot(3, 3, 5);
hist(gyro_y, BIN_COUNT);
grid on;
xlabel('Gyro (dps)');
ylabel('Count');
title('Y-Axis Gyro Distribution');

% Spectral analysis
subplot(3, 3, 6);
NFFT = 2^nextpow2(L);              
Y = fft(gyro_y, NFFT)/L;
f = Fs/2*linspace(0,1,NFFT/2+1);
plot(f,2*abs(Y(1:NFFT/2+1)));
title('Y-Axis Gyro Spectrum');
xlabel('Frequency (Hz)');
ylabel('|Y(f)|');

% Time series
subplot(3, 3, 7);
plot(t, gyro_z);
grid on;
xlabel('Time (s)');
ylabel('Gyro (dps)');
title('Z-Axis Gyro Data');

% Histogram
subplot(3, 3, 8);
hist(gyro_z, BIN_COUNT);
grid on;
xlabel('Gyro (dps)');
ylabel('Count');
title('Z-Axis Gyro Distribution');

% Spectral analysis
subplot(3, 3, 9);
NFFT = 2^nextpow2(L);               
Y = fft(gyro_z, NFFT)/L;
f = Fs/2*linspace(0,1,NFFT/2+1);
plot(f,2*abs(Y(1:NFFT/2+1)));
title('Z-Axis Gyro Spectrum');
xlabel('Frequency (Hz)');
ylabel('|Y(f)|');



### END OF FILE: displayData_gyro.m

### START OF FILE: RunExoskeletonPipeline.m
### FILE Path: AutomationForExoskeleton/scripts/RunExoskeletonPipeline.m
%% RunExoskeletonPipeline.m
% --------------------------------------------------------------------------
% FUNCTION: [] = RunExoskeletonPipeline()
% PURPOSE: Main script to simulate the real-time exoskeleton control system. 
% It integrates Data Acquisition, Sensor Fusion (Kalman), 
% and Locomotion Classification (SVM/FSM) to generate control commands.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Fixed missing gyro data and Kalman interface)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - ImportData.m
% - Features.m
% - RealtimeFsm.m
% - FusionKalman.m 
% - Binary_SVM_Model.mat 
% --------------------------------------------------------------------------
% NOTES:
% - Simulates real-time data flow by iterating over the imported batch data.
% --------------------------------------------------------------------------

clc; clear; close all;

% --- Configuration ---
cfg = ExoConfig();
ACTIVITY_NAME = cfg.ACTIVITY_SIMULATION;
FS = cfg.FS; 
WINDOW_SIZE = cfg.WINDOW_SIZE; 
STEP_SIZE = cfg.STEP_SIZE; 

% --- 1. Load Trained Model ---
model_path = cfg.FILE.SVM_MODEL;
if ~exist(model_path, 'file')
    error('Trained SVM Model not found. Run TrainSvmBinary first.');
end
load(model_path, 'SVMModel');
fprintf('Trained SVM Model loaded successfully.\n');

% --- 2. Initialize Exoskeleton State ---
current_fsm_state = cfg.STATE_STANDING;
hip_flexion_angles = zeros(1, 1); % Initialize array

% --- 3. Initialize Sensor Fusion Filter (Kalman) ---
[fuse_back, fuse_hipL] = initializeFilters(FS);

% --- 4. Load Data ---
try
    [back, hipL, ~, annotations] = ImportData(ACTIVITY_NAME);
catch ME
    warning('Data import failed: %s. Using dummy data.', ME.message);
    data_len = 5000;
    back.acc = [zeros(data_len, 2), ones(data_len, 1)*9.8];
    back.gyro = zeros(data_len, 3);
    hipL = struct('acc', zeros(data_len, 3), 'gyro', zeros(data_len, 3));
    annotations = table(zeros(data_len, 1), 'VariableNames', {'Label'});
end

n_total_samples = size(back.acc, 1);
hip_flexion_angles = zeros(n_total_samples, 1); % Pre-allocate
fsm_plot = zeros(n_total_samples, 1);
last_command = 0;

fprintf('Starting real-time simulation on %d samples...\n', n_total_samples);

% --- 5. Main Real-Time Simulation Loop ---
for i = 1:n_total_samples

    % --- Sensor Fusion (Corrected Logic) ---
    % Standard imufilter usage: q = fuse(acc, gyro)
    q_back = fuse_back(back.acc(i,:), back.gyro(i,:));
    q_hipL = fuse_hipL(hipL.acc(i,:), hipL.gyro(i,:));
    
    % Calculate Angle using the current quaternions
    hip_flexion_angles(i) = estimateAngle(q_back, q_hipL);

    % --- Locomotion Classification ---
    if mod(i - 1, STEP_SIZE) == 0 && (i + WINDOW_SIZE - 1) <= n_total_samples
        windowAcc = back.acc(i : i+WINDOW_SIZE-1, :);
        windowGyro = back.gyro(i : i+WINDOW_SIZE-1, :);

        features_vec = Features(windowAcc, windowGyro, FS);
        new_label = predict(SVMModel, features_vec);
        [exoskeleton_command, current_fsm_state] = RealtimeFsm(new_label, current_fsm_state);
        
        last_command = exoskeleton_command;
    end
    fsm_plot(i) = last_command;
end

fprintf('\nPipeline simulation complete.\n');

% --- 6. Visualization (Plotting code remains the same) ---
figure('Name', 'Pipeline Output');
t = (1:n_total_samples) / FS;

subplot(3,1,1);
plot(t, hip_flexion_angles, 'LineWidth', 1.5);
title('Estimated Left Hip Flexion Angle (Kalman)');
ylabel('Angle (deg)'); grid on;

subplot(3,1,2);
stairs(t, fsm_plot, 'LineWidth', 1.5);
ylim([-0.1 1.1]);
title('Exoskeleton Control Command');
ylabel('Command (0=Stand, 1=Walk)'); grid on;

subplot(3,1,3);
if ismember('Label', annotations.Properties.VariableNames)
    plot(t, annotations.Label, 'k', 'LineWidth', 1.5);
    title('Ground Truth');
end
saveas(gcf, 'results/realtime_pipeline_output.png');
### END OF FILE: RunExoskeletonPipeline.m

### START OF FILE: TestPipelinePerformance.m
### FILE Path: AutomationForExoskeleton/scripts/TestPipelinePerformance.m
%% TestPipelinePerformance.m
% --------------------------------------------------------------------------
% FUNCTION: [metrics] = TestPipelinePerformance()
% PURPOSE: Runs the full real-time simulation pipeline and evaluates the 
% locomotion classification performance against ground truth labels.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Fixed ground truth binarization and missing gyro data)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - ExoConfig.m
% - ImportData.m
% - Features.m
% - RealtimeFsm.m
% - FusionKalman.m
% - Binary_SVM_Model.mat (Trained model)
% --------------------------------------------------------------------------
% NOTES:
% - Loads ground truth from Annotation.csv for the simulated activity.
% - Calculates Accuracy, Precision (Positive Predictive Value), and Recall (Sensitivity).
% --------------------------------------------------------------------------

function [metrics] = TestPipelinePerformance()

clc; close all;
cfg = ExoConfig();

% --- 0. Pre-Flight Check ---
model_path = cfg.FILE.SVM_MODEL;
if ~exist(model_path, 'file')
error('Trained SVM Model not found. Please run TrainSvmBinary first.');
end

% --- 1. Load Trained Model and Configuration ---
% Need to load ModelMetadata to ensure compatibility, even if not fully used here
loaded = load(model_path, 'SVMModel', 'ModelMetadata');
SVMModel = loaded.SVMModel;
ModelMetadata = loaded.ModelMetadata;

FS = ModelMetadata.fs;
WINDOW_SIZE = ModelMetadata.windowSize;
STEP_SIZE = ModelMetadata.stepSize;
ACTIVITY_NAME = cfg.ACTIVITY_SIMULATION;

fprintf('--- Starting Full Pipeline Performance Test ---\n');
fprintf('Simulating Activity: %s (FS: %d Hz)\n', ACTIVITY_NAME, FS);

% --- 2. Load Data and Ground Truth ---
try
[back, hipL, ~, annotations] = ImportData(ACTIVITY_NAME); 
n_total_samples = size(back.acc, 1);

if ~ismember('Label', annotations.Properties.VariableNames) || size(annotations, 1) ~= n_total_samples
error('Annotation file is invalid or size mismatch. Cannot perform evaluation.');
end

ground_truth = annotations.Label; % Multi-class label (e.g., 1, 4, 8)

% Fix: Binarize the ground truth label to match the FSM output (0 or 1)
walking_labels = cfg.DS.USCHAD.WALKING_LABELS; 
non_walking_labels = cfg.DS.USCHAD.NON_WALKING_LABELS; 

ground_truth_binary = zeros(size(ground_truth));
% Map locomotion labels to 1 (WALKING)
ground_truth_binary(ismember(ground_truth, walking_labels)) = cfg.STATE_WALKING; 
% Map non-locomotion labels to 0 (STANDING)
ground_truth_binary(ismember(ground_truth, non_walking_labels)) = cfg.STATE_STANDING; 

catch ME
error('Data loading or ground truth check failed: %s', ME.message);
end

% --- 3. Run Simulation (Simplified Pipeline Loop) ---

% Initialize states and filters
current_fsm_state = cfg.STATE_STANDING; 
fsm_plot = zeros(n_total_samples, 1);
last_command = 0;
% Filters are initialized in RunExoskeletonPipeline, but we initialize here too
[fuse_back, fuse_hipL] = initializeFilters(FS); 

for i = 1:n_total_samples

% Kinematics (Run but results discarded here, focus is on classification)
update(fuse_back, back.acc(i,:), back.gyro(i,:));
update(fuse_hipL, hipL.acc(i,:), hipL.gyro(i,:)); 

% Classification Check
if mod(i - 1, STEP_SIZE) == 0 && (i + WINDOW_SIZE - 1) <= n_total_samples

windowAcc = back.acc(i : i+WINDOW_SIZE-1, :);
windowGyro = back.gyro(i : i+WINDOW_SIZE-1, :); % Fix: Extract Gyro window

% Fix: Pass both Accel and Gyro to Features.m
features_vec = Features(windowAcc, windowGyro, FS); 
new_label = predict(SVMModel, features_vec); 

[exoskeleton_command, current_fsm_state] = RealtimeFsm(new_label, current_fsm_state);
last_command = exoskeleton_command; 
end

fsm_plot(i) = last_command;
end

% --- 4. Performance Evaluation ---

% We compare the FSM output (fsm_plot) against the binarized ground truth.
% True Positives (TP): Walk predicted as Walk
% Fix: Use ground_truth_binary instead of raw ground_truth
TP = sum(ground_truth_binary == 1 & fsm_plot == 1);
% True Negatives (TN): Stand predicted as Stand
TN = sum(ground_truth_binary == 0 & fsm_plot == 0);
% False Positives (FP): Stand predicted as Walk (Type I Error)
FP = sum(ground_truth_binary == 0 & fsm_plot == 1);
% False Negatives (FN): Walk predicted as Stand (Type II Error)
FN = sum(ground_truth_binary == 1 & fsm_plot == 0);

% Calculate Metrics
Accuracy = (TP + TN) / (TP + TN + FP + FN);
Precision = TP / (TP + FP); % How many predicted 'Walks' were correct
Recall = TP / (TP + FN); % How many actual 'Walks' were caught
Specificity = TN / (TN + FP); % How many actual 'Stands' were caught

metrics.TP = TP;
metrics.TN = TN;
metrics.FP = FP;
metrics.FN = FN;
metrics.Accuracy = Accuracy;
metrics.Precision = Precision;
metrics.Recall = Recall;
metrics.Specificity = Specificity;


% --- 5. Report Results ---
fprintf('\n--- Classification Performance Summary ---\n');
fprintf('Target Activity: %s\n', ACTIVITY_NAME);
fprintf('Total Samples: %d\n', n_total_samples);
fprintf('------------------------------------------\n');
fprintf('True Positives (TP): %d\n', TP);
fprintf('True Negatives (TN): %d\n', TN);
fprintf('False Positives (FP): %d\n', FP);
fprintf('False Negatives (FN): %d\n', FN);
fprintf('------------------------------------------\n');
fprintf('SYSTEM ACCURACY: %.2f%%\n', Accuracy * 100);
fprintf('PRECISION (Walk): %.2f%%\n', Precision * 100);
fprintf('RECALL (Walk): %.2f%%\n', Recall * 100);
fprintf('SPECIFICITY (Stand): %.2f%%\n', Specificity * 100);
fprintf('------------------------------------------\n');

end
### END OF FILE: TestPipelinePerformance.m

### START OF FILE: TrainSvmBinary.m
### FILE Path: AutomationForExoskeleton/scripts/TrainSvmBinary.m
%% TrainSvmBinary.m
% --------------------------------------------------------------------------
% FUNCTION: [SVMModel, metrics] = TrainSvmBinary()
% PURPOSE: Trains a binary Support Vector Machine (SVM) classifier for
% Locomotion (1) vs. Static (0) using data from the USC-HAD dataset,
% and saves the model for the real-time pipeline.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Fixed subject-wise splitting logic)
% --------------------------------------------------------------------------
% DEPENDENCIES:
% - ExoConfig.m
% - LoadUSCHAD.m (or any data loading function that returns IMU data)
% - PrepareTrainingData.m
% - Features.m
% --------------------------------------------------------------------------
% NOTES:
% - Uses a 70/30 Subject-wise split for training/testing.
% - Classification is Locomotion (1) vs. Non-Locomotion (0).
% --------------------------------------------------------------------------
function [SVMModel, metrics] = TrainSvmBinary()
clc; clear; close all;
% --- 1. Configuration and Setup ---
cfg = ExoConfig();
% Training parameters
FS = cfg.FS;
WINDOW_SIZE = cfg.WINDOW_SIZE;
STEP_SIZE = cfg.STEP_SIZE;
C_SVM = 1;               % SVM Box Constraint
KERNEL_FUNCTION = 'linear'; % Or 'rbf' for a non-linear boundary
% File paths for data and model saving
model_save_path = cfg.FILE.SVM_MODEL;

fprintf('--- Starting Binary SVM Training Pipeline ---\n');
fprintf('Activity Window: %d samples (%.2f s), Step: %d samples\n', WINDOW_SIZE, WINDOW_SIZE/FS, STEP_SIZE);
fprintf('Kernel Function: %s, Box Constraint (C): %.1f\n', KERNEL_FUNCTION, C_SVM);

% --- 2. Data Acquisition and Splitting (LOGIC FIX APPLIED HERE) ---
try
    % FIX: Load the pre-processed .mat file, which should contain the 'usc' structure
    data_file = cfg.FILE.USCHAD_DATA;
    fprintf('Loading USC-HAD data from: %s...\n', data_file);

    if ~exist(data_file, 'file')
        error('Pre-processed data file not found. Please run LoadUSCHAD.m first to generate it.');
    end
    
    loaded = load(data_file, 'usc');
    all_trials_struct = loaded.usc;

catch ME
    error('Data loading failed. Error: %s', ME.message);
end

% Extract unique subject IDs for subject-wise splitting
all_field_names = fieldnames(all_trials_struct);
% Extract subject ID (e.g., 3 from 'subject3_activity...')
subject_ids_per_trial = cellfun(@(x) sscanf(x, 'subject%d_activity%*d_trial%*d', 1), all_field_names);
unique_subjects = unique(subject_ids_per_trial);

n_subjects = length(unique_subjects);
rng(1); % For reproducibility

% Perform subject-wise split
cv_split = cvpartition(n_subjects, 'Holdout', 0.3);
train_subject_indices = find(cv_split.training);
test_subject_indices = find(cv_split.test);

train_subjects = unique_subjects(train_subject_indices);
test_subjects = unique_subjects(test_subject_indices);

fprintf('Total subjects found: %d. Training subjects: %d, Testing subjects: %d.\n', ...
    n_subjects, length(train_subjects), length(test_subjects));

% Select the field names belonging to the training/testing subjects
train_trial_names = all_field_names(ismember(subject_ids_per_trial, train_subjects));
test_trial_names = all_field_names(ismember(subject_ids_per_trial, test_subjects));

% Reorganize the data into a cell array of trial structs for PrepareTrainingData
all_train_trials = cellfun(@(name) all_trials_struct.(name), train_trial_names, 'UniformOutput', false);
all_test_trials = cellfun(@(name) all_trials_struct.(name), test_trial_names, 'UniformOutput', false);

% --- 3. Feature Extraction and Label Preparation ---
fprintf('Extracting features from training data...\n');
% PrepareTrainingData now correctly receives a cell array of trial structs
[X_train, Y_train] = PrepareTrainingData(all_train_trials, cfg, FS, WINDOW_SIZE, STEP_SIZE);

fprintf('Training Data Matrix (X_train) size: %s\n', mat2str(size(X_train)));
fprintf('Training Label Vector (Y_train) size: %s\n', mat2str(size(Y_train)));

% Check for data balance (important for binary classification)
n_locomotion = sum(Y_train == cfg.STATE_WALKING);
n_static = sum(Y_train == cfg.STATE_STANDING);
fprintf('Training Samples: Locomotion (1): %d, Static (0): %d\n', n_locomotion, n_static);

% --- 4. Model Training (Support Vector Machine) ---
fprintf('Starting SVM training...\n');
% Train a binary classifier
t_start = tic;
SVMModel = fitcsvm(X_train, Y_train, ...
    'KernelFunction', KERNEL_FUNCTION, ...
    'BoxConstraint', C_SVM, ...
    'Standardize', true, ...
    'ClassNames', [cfg.STATE_STANDING, cfg.STATE_WALKING]); % Ensure classes are recognized as 0 and 1
t_elapsed = toc(t_start);
fprintf('SVM training completed in %.2f seconds.\n', t_elapsed);

% --- 5. Model Testing (Evaluation on Holdout Set) ---
fprintf('Extracting features from testing data...\n');
% PrepareTrainingData now correctly receives a cell array of trial structs
[X_test, Y_test] = PrepareTrainingData(all_test_trials, cfg, FS, WINDOW_SIZE, STEP_SIZE);

% Predict labels on the test set
Y_pred = predict(SVMModel, X_test);

% Calculate Performance Metrics
TP = sum(Y_test == cfg.STATE_WALKING & Y_pred == cfg.STATE_WALKING);
TN = sum(Y_test == cfg.STATE_STANDING & Y_pred == cfg.STATE_STANDING);
FP = sum(Y_test == cfg.STATE_STANDING & Y_pred == cfg.STATE_WALKING);
FN = sum(Y_test == cfg.STATE_WALKING & Y_pred == cfg.STATE_STANDING);

Accuracy = (TP + TN) / (TP + TN + FP + FN);
Precision = TP / (TP + FP);
Recall = TP / (TP + FN); % Sensitivity
Specificity = TN / (TN + FP);

metrics.TP = TP;
metrics.TN = TN;
metrics.FP = FP;
metrics.FN = FN;
metrics.Accuracy = Accuracy;
metrics.Precision = Precision;
metrics.Recall = Recall;
metrics.Specificity = Specificity;

fprintf('\n--- Test Set Performance Summary (Holdout Subjects) ---\n');
fprintf('Total Test Samples: %d\n', length(Y_test));
fprintf('------------------------------------------\n');
fprintf('True Positives (TP): %d\n', TP);
fprintf('True Negatives (TN): %d\n', TN);
fprintf('False Positives (FP): %d\n', FP);
fprintf('False Negatives (FN): %d\n', FN);
fprintf('------------------------------------------\n');
fprintf('Accuracy: %.2f%%\n', Accuracy * 100);
fprintf('Precision (Walk): %.2f%%\n', Precision * 100);
fprintf('Recall (Walk): %.2f%%\n', Recall * 100);
fprintf('Specificity (Stand): %.2f%%\n', Specificity * 100);
fprintf('------------------------------------------\n');

% --- 6. Save the Model and Metadata ---
% Metadata needed by the real-time pipeline scripts
ModelMetadata.fs = FS;
ModelMetadata.windowSize = WINDOW_SIZE;
ModelMetadata.stepSize = STEP_SIZE;
ModelMetadata.trainSubjects = train_subjects;
ModelMetadata.testSubjects = test_subjects;
save(model_save_path, 'SVMModel', 'ModelMetadata');

fprintf('\nTrained SVM Model and Metadata saved successfully to: %s\n', model_save_path);
end
### END OF FILE: TrainSvmBinary.m

### START OF FILE: ConcatenateCode.m
### FILE Path: AutomationForExoskeleton/scripts/utils/ConcatenateCode.m
%% ConcatenateCode.m
% --------------------------------------------------------------------------
% FUNCTION: [] = ConcatenateCode()
% PURPOSE: Generates a single, structured file (concatenated_code.txt) 
%          containing the source code of the entire project.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-12
% LAST MODIFIED: 2025-12-15 (Fixed path logic to be location-independent)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
%   - MATLAB built-in file I/O and utility functions (mfilename, fileparts, fullfile, mkdir).
% --------------------------------------------------------------------------
% NOTES:
%   - This version automatically determines the project root by locating the 
%     'scripts/utils' folder (where this script resides) and navigating two 
%     levels up.
%   - The script will work correctly no matter where it is called from, as 
%     long as it remains in 'scripts/utils/'.
%   - Uses '###' headers for visibility and structure.
%   - Output is saved to: [Project Root]/scripts/utils/concatenated_code.txt
% --------------------------------------------------------------------------

% --- Define Paths (Location-Independent Logic) ---

% 1. Get the full path to the currently running script (ConcatenateCode.m)
this_script_path = mfilename('fullpath');
if isempty(this_script_path)
    error('Could not determine script path. Ensure it is saved and on the MATLAB path.');
end

% 2. Determine the project root by traversing up two levels from the script's folder:
%    /scripts/utils/ConcatenateCode.m -> /scripts/utils/ -> /scripts/ -> /AutomationForExoskeleton/
output_dir = fileparts(this_script_path);    % Gets the /scripts/utils/ folder (where output is saved)
scripts_dir = fileparts(output_dir);         % Gets the /scripts/ folder
search_root = fileparts(scripts_dir);        % Gets the /AutomationForExoskeleton/ folder (the project root)

% 3. Extract the project name from the root folder
[~, project_name, ~] = fileparts(search_root);
project_name = strrep(project_name, filesep, '');

% 4. Define the output file path (output_dir is already /scripts/utils/)
output_filename = 'concatenated_code.txt';
output_full_path = fullfile(output_dir, output_filename);

% Ensure the output directory exists
if ~exist(output_dir, 'dir')
    mkdir(output_dir);
end
% --------------------------------------------------

fprintf('Starting code concatenation for copying...\n');

% 1. Find all .m files recursively and filter hidden folders
search_path = fullfile(search_root, '**', '*.m');
listing = dir(search_path);

files_to_concatenate = [];
for i = 1:length(listing)
    full_path = fullfile(listing(i).folder, listing(i).name);
    
    % Get the path relative to the true project root
    rel_path = extractAfter(full_path, search_root);
    if startsWith(rel_path, filesep)
        rel_path = extractAfter(rel_path, filesep);
    end
    
    % Check if any part of the path starts with a '.' (e.g., .git/...)
    parts = strsplit(rel_path, filesep);
    if ~any(startsWith(parts, '.'))
        files_to_concatenate = [files_to_concatenate; listing(i)];
    end
end

if isempty(files_to_concatenate)
    fprintf('No .m files found in visible project directories.\n');
    return;
end

% --- CUSTOM SORTING: Ensure correct file order (Root files first, then subfolders by path) ---
files_to_sort = files_to_concatenate; 
% 1. Calculate the relative path for every file
relative_paths = cell(length(files_to_sort), 1);
for i = 1:length(files_to_sort)
    full_path_abs = fullfile(files_to_sort(i).folder, files_to_sort(i).name);
    
    % Get the path relative to the true project root for sorting
    rel_path = extractAfter(full_path_abs, search_root);
    if startsWith(rel_path, filesep)
        rel_path = extractAfter(rel_path, filesep);
    end
    
    % Add a special prefix to root files to force them to sort first
    if isempty(fileparts(rel_path))
        relative_paths{i} = ['!', rel_path]; 
    else
        relative_paths{i} = rel_path;
    end
end
% 2. Sort the files based on the relative path strings
[~, idx] = sort(relative_paths);
files_to_concatenate = files_to_sort(idx);
% --------------------------------------------------------------------------------------------

% 2. Open the output file for writing (will overwrite if it exists)
fileID = fopen(output_full_path, 'wt', 'n', 'UTF-8');
if fileID == -1
    error('Could not open file for writing: %s', output_full_path);
end

% 3. Process and print/write each file
fprintf('\n--- CONCATENATED CODE START ---\n\n');

% Write the global header to the file (only to file)
fprintf(fileID, '--- CONCATENATED CODE FROM PROJECT: %s ---\n\n', project_name);

for i = 1:length(files_to_concatenate)
    file_info = files_to_concatenate(i);
    
    full_path_abs = fullfile(file_info.folder, file_info.name);
    
    % Construct the desired 'FILE Path' using the dynamic project name and relative segment
    rel_path_segment = extractAfter(full_path_abs, search_root);
    if startsWith(rel_path_segment, filesep)
        rel_path_segment = extractAfter(rel_path_segment, filesep);
    end
    
    % The output path format is now: ProjectName/relative/path/to/file.m
    file_path_output = sprintf('%s/%s', project_name, rel_path_segment);
    
    % Read the content of the file
    file_content = fileread(full_path_abs);
    
    % --- Generate Custom Structured Header (USING 3 HASH SIGNS) ---
    header_start_line1 = sprintf('### START OF FILE: %s\n', file_info.name);
    header_start_line2 = sprintf('### FILE Path: %s\n', file_path_output);
    header_end = sprintf('### END OF FILE: %s\n\n', file_info.name);
    
    % Print structured output to Command Window
    fprintf(header_start_line1);
    fprintf(header_start_line2);
    fprintf('%s\n', file_content); 
    fprintf(header_end);
    
    % Write structured output to the text file
    fprintf(fileID, header_start_line1);
    fprintf(fileID, header_start_line2);
    fprintf(fileID, '%s\n', file_content);
    fprintf(fileID, header_end);
end

% 4. Close the file and finalize output
fclose(fileID);

fprintf('\n--- CONCATENATED CODE END ---\n');
fprintf('Content printed to terminal for immediate copy/paste.\n');
fprintf('A consolidated version has also been saved to: %s\n', output_full_path);
### END OF FILE: ConcatenateCode.m

### START OF FILE: GenerateProjectTree.m
### FILE Path: AutomationForExoskeleton/scripts/utils/GenerateProjectTree.m
%% GenerateProjectTree.m
% --------------------------------------------------------------------------
% FUNCTION: GenerateProjectTree()
% PURPOSE : Generates a readable project directory tree and saves it to
%           scripts/utils/project_tree.txt
% FEATURES:
%   - Automatically finds project root regardless of current directory
%   - Shows first 3 items in folders with >10 contents
%   - Truncates large folders with "... (truncated: X more items)"
%   - Clean, properly aligned tree visualization
%   - Excludes hidden files/folders
% --------------------------------------------------------------------------
% AUTHOR     : Your Name
% CREATED    : 2025-12-12
% LAST UPDATE: 2025-12-16 (Fixed ternary operators, improved alignment)
% --------------------------------------------------------------------------

function GenerateProjectTree()

    % --- Determine paths (location-independent) ---
    this_script_path = mfilename('fullpath');
    if isempty(this_script_path)
        error('Cannot determine script path. Save the file and add to MATLAB path.');
    end

    utils_dir    = fileparts(this_script_path);           % scripts/utils/
    scripts_dir  = fileparts(utils_dir);                  % scripts/
    project_root = fileparts(scripts_dir);                % AutomationForExoskeleton/

    output_file  = fullfile(utils_dir, 'project_tree.txt');

    % --- Clean previous output ---
    if exist(output_file, 'file')
        delete(output_file);
    end

    fprintf('Starting project structure generation...\n');

    % --- Start capturing output to file ---
    diary(output_file);
    try
        [~, root_name] = fileparts(project_root);
        fprintf('%s/\n', root_name);

        drawTree(project_root, '');

    catch ME
        diary off;
        warning('Error during tree generation: %s', ME.message);
        rethrow(ME);
    end
    diary off;

    fprintf('Scan completed and saved to %s.\n', output_file);
end

%% --- Recursive Tree Drawing Function ---
function drawTree(current_path, prefix)

    % Get and filter directory contents
    listing = dir(current_path);
    is_valid = ~ismember({listing.name}, {'.', '..'});
    listing  = listing(is_valid);
    is_hidden = startsWith({listing.name}, '.');
    listing  = listing(~is_hidden);

    if isempty(listing)
        return;
    end

    % Separate and sort folders/files (case-insensitive)
    folders = listing([listing.isdir]);
    files   = listing(~[listing.isdir]);

    [~, idx_f] = sort(lower({folders.name}));
    [~, idx_i] = sort(lower({files.name}));

    folders = folders(idx_f);
    files   = files(idx_i);

    all_entries = [folders; files];
    N = length(all_entries);

    % Process each entry
    for i = 1:N
        entry   = all_entries(i);
        is_last = (i == N);

        % Determine connector and next prefix
        if is_last
            connector           = '└── ';
            next_prefix_segment = '    ';  % 4 spaces for alignment
        else
            connector           = '├── ';
            next_prefix_segment = '│   ';  % │ + 3 spaces
        end

        % Print current item
        name = entry.name;
        if entry.isdir
            name = [name, '/'];
        end
        fprintf('%s%s%s\n', prefix, connector, name);

        % If it's a folder, expand partially or fully
        if entry.isdir
            new_path   = fullfile(current_path, entry.name);
            new_prefix = [prefix, next_prefix_segment];

            % Count visible contents
            sub_list   = dir(new_path);
            sub_valid  = ~ismember({sub_list.name}, {'.', '..'});
            sub_hidden = startsWith({sub_list.name}, '.');
            sub_count  = sum(sub_valid & ~sub_hidden);

            if sub_count > 10
                % --- Show only first 3 items + truncation ---
                sub_entries = sub_list(sub_valid & ~sub_hidden);

                sub_folders = sub_entries([sub_entries.isdir]);
                sub_files   = sub_entries(~[sub_entries.isdir]);

                [~, sf_idx]  = sort(lower({sub_folders.name}));
                [~, sfi_idx] = sort(lower({sub_files.name}));

                sub_sorted = [sub_folders(sf_idx); sub_files(sfi_idx)];
                num_show   = min(3, length(sub_sorted));

                for k = 1:num_show
                    sub_entry = sub_sorted(k);
                    sub_name  = sub_entry.name;
                    if sub_entry.isdir
                        sub_name = [sub_name, '/'];
                    end

                    if k == num_show
                        sub_conn = '└── ';
                    else
                        sub_conn = '├── ';
                    end

                    fprintf('%s%s%s\n', new_prefix, sub_conn, sub_name);
                end

                remaining = sub_count - 3;
                if remaining > 0
                    fprintf('%s└── ... (truncated: %d more items)\n', new_prefix, remaining);
                end

            else
                % --- Show all contents (≤10 items) ---
                drawTree(new_path, new_prefix);
            end
        end
    end
end
### END OF FILE: GenerateProjectTree.m

### START OF FILE: ImportData.m
### FILE Path: AutomationForExoskeleton/src/acquisition/ImportData.m
%% ImportData.m
% --------------------------------------------------------------------------
% FUNCTION: [back, hipL, hipR, annotations] = ImportData(activityName)
% PURPOSE: Implements the Data Acquisition Protocol, reading raw CSV data from 
% a specified activity folder (assuming a single IMU on the back).
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-11
% LAST MODIFIED: 2025-12-13 (Fixed dummy data sizing for hipL/hipR)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - process_imu_table (Nested function)
% --------------------------------------------------------------------------
% NOTES:
% - Assumes raw CSV files are named Accelerometer.csv, Gyroscope.csv, etc. 
% within the '../data/raw/<activityName>/' folder.
% - This function is currently adapted to load the *single* IMU data found in 
% the raw directory and assigns it to the 'back' sensor. 
% - 'hipL' and 'hipR' are returned as zero arrays for pipeline compatibility.
% --------------------------------------------------------------------------

function [back, hipL, hipR, annotations] = ImportData(activityName)
% Define path to the specific activity folder
baseDir = '../data/raw/';
activityPath = fullfile(baseDir, activityName);

% Filenames
fileAcc = fullfile(activityPath, 'Accelerometer.csv');
fileGyro = fullfile(activityPath, 'Gyroscope.csv');
fileAnnot = fullfile(activityPath, 'Annotation.csv'); % Includes ground truth labels

% Check files exist
if ~isfolder(activityPath)
error('Activity folder not found: %s', activityPath);
end
if ~isfile(fileAcc) || ~isfile(fileGyro)
error('IMU data files not found in: %s', activityPath);
end

% --- 1. Import Raw Tables ---
opts = detectImportOptions(fileAcc);
accTable = readtable(fileAcc, opts);

opts = detectImportOptions(fileGyro);
gyroTable = readtable(fileGyro, opts);

if isfile(fileAnnot)
opts = detectImportOptions(fileAnnot);
annotations = readtable(fileAnnot, opts);
else
warning('Annotation file not found. Returning empty table.');
annotations = table();
end

% --- 2. Process and Assign Data ---
back = process_imu_table(accTable, gyroTable);
N_samples = size(back.acc, 1);

% Fix: Create dummy zero data with correct N_samples size
hipL.acc = zeros(N_samples, 3);
hipL.gyro = zeros(N_samples, 3);
hipR.acc = zeros(N_samples, 3);
hipR.gyro = zeros(N_samples, 3);

fprintf('Imported %d samples of IMU data for activity "%s".\n', N_samples, activityName);
end

%% --- NESTED FUNCTION (Utility for Table Processing) ---
function imu = process_imu_table(accTable, gyroTable)
% Converts imported tables to standard IMU data structure (Nx3 arrays).

% Error checking for missing data (as dummy creation is now handled by the caller)
if isempty(accTable) || isempty(gyroTable)
    error('process_imu_table: Called without data. Data loading failed.');
end

imu.acc = table2array(accTable);
imu.gyro = table2array(gyroTable);
end
### END OF FILE: ImportData.m

### START OF FILE: PrepareTrainingData.m
### FILE Path: AutomationForExoskeleton/src/acquisition/PrepareTrainingData.m
%% PrepareTrainingData.m
% --------------------------------------------------------------------------
% FUNCTION: [features, labels_binary, ModelMetadata] = PrepareTrainingData(cfg)
% PURPOSE: Loads data, extracts features in sliding windows, and binarizes 
% the labels for binary SVM training (WALKING=1, STANDING=0).
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Added ModelMetadata output)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - ExoConfig.m
% - LoadUSCHAD.m (to ensure data is processed)
% - ImportUschadSingleImu.m
% - Features.m
% --------------------------------------------------------------------------

function [features, labels_binary, ModelMetadata] = PrepareTrainingData(cfg)

if nargin < 1
    cfg = ExoConfig();
end

% --- 1. Load USC-HAD Data Structure ---
% NOTE: Assuming LoadUSCHAD has been run and usc_had_dataset.mat exists
load(cfg.FILE.USCHAD_DATA, 'usc');

% Prepare lists for feature vectors and corresponding binary labels
features = [];
labels_binary = [];
all_trial_names = fieldnames(usc);

fprintf('Starting feature extraction on %d USC-HAD trials...\n', length(all_trial_names));

% --- 2. Iterate through all trials ---
for i = 1:length(all_trial_names)
    trial_name = all_trial_names{i};
    trial = usc.(trial_name);
    
    % Use only the 'back' IMU data (single IMU pipeline simulation)
    acc = trial.acc;
    gyro = trial.gyro;
    raw_label = trial.label;
    
    n_samples = size(acc, 1);
    
    % Binarize the single trial label
    is_walking = ismember(raw_label, cfg.DS.USCHAD.WALKING_LABELS);
    trial_label_binary = double(is_walking);

    % --- Sliding Window Feature Extraction ---
    for k = 1:cfg.STEP_SIZE:(n_samples - cfg.WINDOW_SIZE + 1)
        window_start = k;
        window_end = k + cfg.WINDOW_SIZE - 1;
        
        windowAcc = acc(window_start:window_end, :);
        windowGyro = gyro(window_start:window_end, :);

        % Extract Features (pass both Accel and Gyro)
        feature_vector = Features(windowAcc, windowGyro, cfg.FS);
        
        features = [features; feature_vector]; %#ok<AGROW>
        labels_binary = [labels_binary; trial_label_binary]; %#ok<AGROW>
    end
end

% --- 3. Prepare Metadata ---
ModelMetadata.fs = cfg.FS;
ModelMetadata.windowSize = cfg.WINDOW_SIZE;
ModelMetadata.stepSize = cfg.STEP_SIZE;
% Fix: Save the raw multi-class labels used for binarization (CRITICAL for evaluation scripts)
ModelMetadata.WALKING_LABELS_RAW = cfg.DS.USCHAD.WALKING_LABELS; 
ModelMetadata.NON_WALKING_LABELS_RAW = cfg.DS.USCHAD.NON_WALKING_LABELS;

fprintf('Feature extraction complete. Total %d windows generated.\n', size(features, 1));
end
### END OF FILE: PrepareTrainingData.m

### START OF FILE: Classifier.m
### FILE Path: AutomationForExoskeleton/src/classification/Classifier.m
%% Classifier.m
% --------------------------------------------------------------------------
% FUNCTION: [performance] = EvaluateClassifier(test_trial_name)
% PURPOSE: Loads a trained SVM and tests its performance on a specific, 
% held-out single trial from the USC-HAD dataset.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Fixed label handling/binarization)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - ExoConfig.m
% - ImportUschadSingleImu.m
% - Features.m
% --------------------------------------------------------------------------
% NOTES:
% - Calculates window-by-window classification accuracy.
% --------------------------------------------------------------------------

function [performance] = Classifier(test_trial_name)

clc;
cfg = ExoConfig();

% --- 0. Pre-Flight Check ---
model_path = cfg.FILE.SVM_MODEL;
if ~exist(model_path, 'file')
error('Trained SVM Model not found. Please run TrainSvmBinary first.');
end

% --- 1. Load Trained Model and Metadata ---
loaded = load(model_path, 'SVMModel', 'ModelMetadata');
SVMModel = loaded.SVMModel;
ModelMetadata = loaded.ModelMetadata;

FS = ModelMetadata.fs;
WINDOW_SIZE = ModelMetadata.windowSize;
STEP_SIZE = ModelMetadata.stepSize;

fprintf('--- Starting Classifier Evaluation ---\n');
fprintf('Testing on trial: %s (FS: %d Hz)\n', test_trial_name, FS);

% --- 2. Load Test Data and Determine Ground Truth ---
try
% Fix: Corrected function signature call (returns 3 IMU structs)
[back, ~, ~] = ImportUschadSingleImu(test_trial_name); 

% Load the USC structure to get the activity ID for the test trial
loaded_usc = load(cfg.FILE.USCHAD_DATA, 'usc');
raw_activity_id = loaded_usc.usc.(test_trial_name).label;

n_total_samples = size(back.acc, 1);

% Fix: Binarize the ground truth label based on the ModelMetadata
if ismember(raw_activity_id, ModelMetadata.WALKING_LABELS_RAW)
    ground_truth_binary = cfg.STATE_WALKING; % 1
else
    ground_truth_binary = cfg.STATE_STANDING; % 0
end

% Create a ground truth label for every *window*
n_windows = floor((n_total_samples - ModelMetadata.windowSize) / ModelMetadata.stepSize) + 1;
ground_truth_windows = repmat(ground_truth_binary, n_windows, 1);

catch ME
error('Data loading or ground truth determination failed: %s', ME.message);
end

% --- 3. Extract Features for Test Data ---
test_features = [];
window_labels = []; % Store the predicted label for each window

for k = 1:STEP_SIZE:(n_total_samples - WINDOW_SIZE + 1)
    window_start = k;
    window_end = k + WINDOW_SIZE - 1;

    windowAcc = back.acc(window_start:window_end, :);
    windowGyro = back.gyro(window_start:window_end, :); % Include Gyro

    feature_vector = Features(windowAcc, windowGyro, FS);
    test_features = [test_features; feature_vector]; %#ok<AGROW>
end

% --- 4. Classify All Windows ---
predicted_labels = predict(SVMModel, test_features);


% --- 5. Performance Evaluation (Window-by-Window) ---
TP = sum(ground_truth_windows == 1 & predicted_labels == 1);
TN = sum(ground_truth_windows == 0 & predicted_labels == 0);
FP = sum(ground_truth_windows == 0 & predicted_labels == 1);
FN = sum(ground_truth_windows == 1 & predicted_labels == 0);

Accuracy = (TP + TN) / (TP + TN + FP + FN);
Precision = TP / (TP + FP); 
Recall = TP / (TP + FN); 
Specificity = TN / (TN + FP);

performance.TP = TP;
performance.TN = TN;
performance.FP = FP;
performance.FN = FN;
performance.Accuracy = Accuracy;
performance.Precision = Precision;
performance.Recall = Recall;
performance.Specificity = Specificity;

% --- 6. Report Results ---
fprintf('\n--- Classification Performance Summary (Window-by-Window) ---\n');
fprintf('Target Label: %d (WALK=%d, STAND=%d)\n', ground_truth_binary, cfg.STATE_WALKING, cfg.STATE_STANDING);
fprintf('Total Windows: %d\n', n_windows);
fprintf('------------------------------------------\n');
fprintf('Accuracy: %.2f%%\n', Accuracy * 100);
fprintf('Precision: %.2f%%\n', Precision * 100);
fprintf('Recall: %.2f%%\n', Recall * 100);
fprintf('------------------------------------------\n');

end
### END OF FILE: Classifier.m

### START OF FILE: RealtimeFsm.m
### FILE Path: AutomationForExoskeleton/src/classification/RealtimeFsm.m
%% RealtimeFsm.m
% --------------------------------------------------------------------------
% FUNCTION: [command, new_state] = RealtimeFsm(classified_label, current_state)
% PURPOSE: Implements a simple Finite State Machine (FSM) to transition
% the exoskeleton control state based on the SVM classification output.
% It prevents rapid, noisy switching between STANDING (0) and WALKING (1).
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Initial implementation)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - ExoConfig.m (Requires constants for state definitions)
% --------------------------------------------------------------------------
% NOTES:
% - State 0: STANDING/NON-LOCOMOTION
% - State 1: WALKING/LOCOMOTION
% - COMMAND is the output signal for the exoskeleton actuators (0 or 1).
% --------------------------------------------------------------------------

function [command, new_state] = RealtimeFsm(classified_label, current_state)

% Load Configuration for State Constants
cfg = ExoConfig();
STATE_STANDING = cfg.STATE_STANDING; % Should be 0
STATE_WALKING = cfg.STATE_WALKING;   % Should be 1

% --- FSM Parameters (Adjust these for sensitivity/latency trade-off) ---
% The number of consecutive WALKING predictions required to transition from STANDING to WALKING.
WALK_ENTRY_THRESHOLD = 3; 
% The number of consecutive STANDING predictions required to transition from WALKING to STANDING.
STAND_EXIT_THRESHOLD = 5; 

persistent walk_counter stand_counter;

% Initialize counters on first call
if isempty(walk_counter) || isempty(stand_counter)
    walk_counter = 0;
    stand_counter = 0;
end

% --- 1. Update Transition Counters ---

if classified_label == STATE_WALKING
    walk_counter = walk_counter + 1;
    stand_counter = 0; % Reset opposing counter
else % classified_label == STATE_STANDING
    stand_counter = stand_counter + 1;
    walk_counter = 0; % Reset opposing counter
end


% --- 2. State Transition Logic ---

new_state = current_state; % Assume state remains the same

switch current_state
    case STATE_STANDING
        % Current State: STANDING (0)
        
        % Check for transition to WALKING
        if walk_counter >= WALK_ENTRY_THRESHOLD
            new_state = STATE_WALKING;
            % Reset counter for the new state's exit condition
            stand_counter = 0; 
            fprintf('FSM Transition: STANDING -> WALKING\n');
        end
        
    case STATE_WALKING
        % Current State: WALKING (1)
        
        % Check for transition back to STANDING
        if stand_counter >= STAND_EXIT_THRESHOLD
            new_state = STATE_STANDING;
            % Reset counter for the new state's exit condition
            walk_counter = 0;
            fprintf('FSM Transition: WALKING -> STANDING\n');
        end
        
    otherwise
        % Handle unexpected state (should not happen)
        warning('FSM received an unexpected current state: %d. Defaulting to STANDING.', current_state);
        new_state = STATE_STANDING;
        
end


% --- 3. Generate Control Command ---

% The control command is typically the new state itself, representing 
% whether the exoskeleton should be providing locomotion assistance (1) or 
% locked/idle (0).
command = new_state;

end
### END OF FILE: RealtimeFsm.m

### START OF FILE: StateEstimator.m
### FILE Path: AutomationForExoskeleton/src/classification/StateEstimator.m
%% StateEstimator.m
% --------------------------------------------------------------------------
% FUNCTION: [command, state] = updateFSM(new_label, current_state)
% PURPOSE: Implements the Finite State Machine (FSM) to manage transitions between locomotion modes and generate exoskeleton control commands.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-11
% LAST MODIFIED: 2025-12-13
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - None (Self-contained logic)
% --------------------------------------------------------------------------
% NOTES:
% - State smoothing: requires 3 consecutive labels to confirm a state change.
% - The output `command` is a simple low-level signal (e.g., 0=stand, 1=walk gait).
% --------------------------------------------------------------------------

function [command, next_state] = StateEstimator(new_label, current_state)

% --- Configuration Parameters ---
persistent state_counter % Persist across calls to track consecutive labels
if isempty(state_counter)
    state_counter = 0; % 0: Consecutive label counter
end

% Required consecutive labels to confirm a state transition
CONFIRMATION_THRESHOLD = 3; 

% --- State Definitions ---
% Use descriptive integer codes
STATE_STANDING = 0;
STATE_WALKING = 1;

% Assuming new_label comes from SVM (0=Stand, 1=Walk)

% Initialize next state and command to current values
next_state = current_state;
command = current_state; % Command is typically the same as the final state

% ----------------------------------------------------------------
% 1. CHECK FOR CONSISTENCY (Smoothing)
% ----------------------------------------------------------------

if new_label == next_state
    % Label matches current state, reset counter
    state_counter = 0;
    return; % No state change needed
end

% ----------------------------------------------------------------
% 2. CHECK FOR TRANSITION
% ----------------------------------------------------------------

if new_label ~= next_state
    % Label suggests a change; increment counter
    state_counter = state_counter + 1;

    if state_counter >= CONFIRMATION_THRESHOLD
        % Threshold reached: Execute the transition
        
        if current_state == STATE_STANDING && new_label == STATE_WALKING
            % Transition: STANDING -> WALKING
            next_state = STATE_WALKING;
            command = 1; % Low-level command to initiate walking gait
            fprintf('FSM Transition: STANDING -> WALKING\n');

        elseif current_state == STATE_WALKING && new_label == STATE_STANDING
            % Transition: WALKING -> STANDING
            next_state = STATE_STANDING;
            command = 0; % Low-level command to lock/stop exoskeleton
            fprintf('FSM Transition: WALKING -> STANDING\n');
        end

        % Reset counter after successful transition
        state_counter = 0;
    end
end

% If the threshold was not reached, next_state remains current_state
end
### END OF FILE: StateEstimator.m

### START OF FILE: Features.m
### FILE Path: AutomationForExoskeleton/src/features/Features.m
%% Features.m
% --------------------------------------------------------------------------
% FUNCTION: [features_out] = Features(windowAcc, windowGyro, Fs)
% PURPOSE: Calculates time-domain and frequency-domain features from IMU data windows for use in the locomotion classifier.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-11
% LAST MODIFIED: 2025-12-14 (Header fix)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - MATLAB built-in functions (fft, abs, mean, var, max)
% --------------------------------------------------------------------------
% NOTES:
% - Calculates mean/variance of acceleration magnitude and the dominant frequency.
% - Dominant frequency is crucial for distinguishing steady-state walking (1-2 Hz).
% - Currently ignores windowGyro input (~).
% --------------------------------------------------------------------------

function [features_out] = Features(windowAcc, ~, Fs)

% 1. Time-Domain Features (Used in TrainSvmBinary.m)
% Calculate magnitude of acceleration vector (net force)
mag_acc = sqrt(sum(windowAcc.^2, 2));

% Feature 1: Mean of Acceleration Magnitude
feat_mean_mag = mean(mag_acc);

% Feature 2: Variance of Acceleration Magnitude
feat_var_mag = var(mag_acc);


% 2. Frequency-Domain Features
N = length(windowAcc);
if N < 2
% Handle edge case of very small window
features_out = [feat_mean_mag, feat_var_mag, 0];
return; 
end

% Perform Fast Fourier Transform (FFT) on the raw Z-axis of acceleration
% Z-axis (vertical/gravity) often has the clearest gait signature
acc_z = windowAcc(:, 3); % Assuming Z is the 3rd column

Y = fft(acc_z);
P2 = abs(Y/N);
P1 = P2(1:floor(N/2)+1); % Single-sided spectrum
P1(2:end-1) = 2*P1(2:end-1);

% Frequency vector
f = Fs*(0:floor(N/2))/N;

% Feature 3: Dominant Frequency (excluding DC component at f(1)=0)
[~, idx] = max(P1(2:end)); % Find peak amplitude index, starting from index 2
feat_dom_freq = f(idx + 1); % Adjust index back to frequency vector f

% 3. Output
% Combine all features into a single row vector
features_out = [feat_mean_mag, feat_var_mag, feat_dom_freq];

end
### END OF FILE: Features.m

### START OF FILE: FusionKalman.m
### FILE Path: AutomationForExoskeleton/src/fusion/FusionKalman.m
%% FusionKalman.m
% --------------------------------------------------------------------------
% FUNCTION: [fuse_back, fuse_hipL] = initializeFilters(Fs)
% FUNCTION: [hipFlexionAngle] = estimateAngle(orientBack, orientHipL)
% PURPOSE: Provides configuration and helper functions for the Kalman Filter 
%          used for sensor fusion (Accel/Gyro) to estimate joint angles.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-11
% LAST MODIFIED: 2025-12-15 (Refactored to provide modular filter objects)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - MATLAB Sensor Fusion Toolbox (imufilter, quat2eul)
% --------------------------------------------------------------------------
% NOTES:
% - The filter objects must be initialized once and updated incrementally 
%   by the main pipeline script.
% - Tuning parameters are defined here to achieve the desired RMSE.
% --------------------------------------------------------------------------

function [fuse_back, fuse_hipL] = initializeFilters(Fs)
    % Tuning parameters (optimized for exoskeleton kinematics)
    ACCEL_NOISE = 0.01; 
    GYRO_NOISE = 0.005;

    fprintf('Initializing Kalman IMU Filters (SampleRate: %d Hz)...\n', Fs);
    
    % Initialize filter for the Back IMU (Standard MATLAB imufilter)
    fuse_back = imufilter('SampleRate', Fs, ...
        'AccelerometerNoise', ACCEL_NOISE, ...
        'GyroscopeNoise', GYRO_NOISE, ...
        'ReferenceFrame', 'ENU');

    % Initialize filter for the Left Hip IMU
    fuse_hipL = imufilter('SampleRate', Fs, ...
        'AccelerometerNoise', ACCEL_NOISE, ...
        'GyroscopeNoise', GYRO_NOISE, ...
        'ReferenceFrame', 'ENU');
end

function hipFlexionAngle = estimateAngle(orientBack, orientHipL)
    % PURPOSE: Computes relative joint angle from two orientation quaternions.
    % INPUTS: orientBack, orientHipL (1x4 quaternions or quaternion objects)
    
    % 1. Data Safety: Ensure inputs are valid
    if any(isnan(orientBack)) || any(isnan(orientHipL))
        hipFlexionAngle = 0;
        return;
    end

    % 2. Convert to Euler Angles (ZYX: Yaw, Pitch, Roll)
    % Note: Pitch (index 2) usually corresponds to flexion/extension
    eulBack = quat2eul(orientBack, 'ZYX');
    eulHipL = quat2eul(orientHipL, 'ZYX');

    % 3. Calculate Relative Angle (Difference in Pitch)
    angle_rad = eulHipL(2) - eulBack(2);
    
    % 4. Convert to degrees
    hipFlexionAngle = angle_rad * (180/pi);
end
### END OF FILE: FusionKalman.m

### START OF FILE: acquisition_test.m
### FILE Path: AutomationForExoskeleton/tests/acquisition_test.m

### END OF FILE: acquisition_test.m

### START OF FILE: classification_test.m
### FILE Path: AutomationForExoskeleton/tests/classification_test.m

### END OF FILE: classification_test.m

