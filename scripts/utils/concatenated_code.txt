--- CONCATENATED CODE FROM PROJECT: scripts ---

### START OF FILE: RunExoskeletonPipeline.m
### FILE Path: scripts/RunExoskeletonPipeline.m
%% RunExoskeletonPipeline.m
% --------------------------------------------------------------------------
% FUNCTION: [] = RunExoskeletonPipeline()
% PURPOSE: Main script to simulate the real-time exoskeleton control system. 
% It integrates Data Acquisition, Sensor Fusion (Kalman), 
% and Locomotion Classification (SVM/FSM) to generate control commands.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Fixed missing gyro data and Kalman interface)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - ImportData.m
% - Features.m
% - RealtimeFsm.m
% - FusionKalman.m 
% - Binary_SVM_Model.mat 
% --------------------------------------------------------------------------
% NOTES:
% - Simulates real-time data flow by iterating over the imported batch data.
% --------------------------------------------------------------------------

clc; clear; close all;

% --- Configuration (Use ExoConfig for centralized management) ---
cfg = ExoConfig();
ACTIVITY_NAME = cfg.ACTIVITY_SIMULATION; 
FS = cfg.FS; 
WINDOW_SIZE = cfg.WINDOW_SIZE; 
STEP_SIZE = cfg.STEP_SIZE; 

% --- 1. Load Trained Model ---
model_path = cfg.FILE.SVM_MODEL;
if ~exist(model_path, 'file')
error('Trained SVM Model not found. Please run TrainSvmBinary first to generate: %s', model_path);
end
load(model_path, 'SVMModel');
fprintf('Trained SVM Model loaded successfully.\n');

% --- 2. Initialize Exoskeleton State ---
current_fsm_state = cfg.STATE_STANDING; % 0: STANDING, 1: WALKING
hip_flexion_angles = []; % Store estimated joint angles

% --- 3. Initialize Sensor Fusion Filter (Kalman) ---
% Using the new modular function from FusionKalman.m
[fuse_back, fuse_hipL] = initializeFilters(FS); 
fprintf('Kalman Filter initialized for real-time operation.\n');

% --- 4. Load Data for Simulation (Data Acquisition Protocol) ---
try
[back, hipL, ~, annotations] = ImportData(ACTIVITY_NAME); 
catch ME
warning('Data import failed via ImportData.m: %s. Falling back to dummy data.', ME.message);
% Dummy data fallback if ImportData fails to read CSVs
data_len = 5000;
back.acc = [zeros(data_len, 2), ones(data_len, 1)*9.8];
back.gyro = zeros(data_len, 3);
hipL = struct('acc', zeros(data_len, 3), 'gyro', zeros(data_len, 3));
annotations = table(zeros(data_len, 1), 'VariableNames', {'Label'}); 
end

n_total_samples = size(back.acc, 1);
fprintf('Starting real-time simulation on %d samples...\n', n_total_samples);

% --- 5. Main Real-Time Simulation Loop ---
fsm_plot = zeros(n_total_samples, 1);
last_command = 0;

for i = 1:n_total_samples

% --- Sensor Fusion (Incremental Update) ---
% 1. Update IMU filters with current sample (i). The filter object's state is updated internally.
update(fuse_back, back.acc(i,:), back.gyro(i,:));
update(fuse_hipL, hipL.acc(i,:), hipL.gyro(i,:));

% 2. Calculate current hip flexion angle
% Fix: Pass the filter objects (which hold the state) directly.
current_angle = estimateAngle(fuse_back, fuse_hipL); 
hip_flexion_angles(i) = current_angle; %#ok<AGROW>

% --- Locomotion Classification (Sliding Window Check) ---
if mod(i - 1, STEP_SIZE) == 0 && (i + WINDOW_SIZE - 1) <= n_total_samples

windowAcc = back.acc(i : i+WINDOW_SIZE-1, :);
windowGyro = back.gyro(i : i+WINDOW_SIZE-1, :); % Fix: Extract Gyro window

% 1. Extract Features
% Fix: Pass both Accel and Gyro to Features.m
features_vec = Features(windowAcc, windowGyro, FS); 

% 2. Classify (Predict the next label)
new_label = predict(SVMModel, features_vec); 

% 3. Update FSM and get command
[exoskeleton_command, current_fsm_state] = RealtimeFsm(new_label, current_fsm_state);

last_command = exoskeleton_command; 

fprintf('Time step %d: Classification Label=%d, FSM State=%d, Command=%d\n', ...
i, new_label, current_fsm_state, exoskeleton_command);
end

% Store the current command for this sample index
fsm_plot(i) = last_command;
end

% --- 6. Visualization and Finalization ---
fprintf('\nPipeline simulation complete.\n');

figure('Name', 'Pipeline Output');
t = (1:n_total_samples) / FS;

subplot(3,1,1);
plot(t, hip_flexion_angles, 'LineWidth', 1.5);
title('Estimated Left Hip Flexion Angle (Kalman)');
ylabel('Angle (deg)');
grid on;

subplot(3,1,2);
stairs(t, fsm_plot, 'LineWidth', 1.5);
ylim([-0.1 1.1]);
yticks([0 1]);
yticklabels({'STANDING', 'WALKING'});
title('Exoskeleton Control Command (FSM Output)');
ylabel('Command');
grid on;

subplot(3,1,3);
if ismember('Label', annotations.Properties.VariableNames) && size(annotations, 1) == n_total_samples
plot(t, annotations.Label, 'LineWidth', 1.5, 'Color', 'k');
title('Ground Truth Label (from Annotation.csv)');
xlabel('Time (s)');
ylabel('Label');
grid on;
else
text(0.5, 0.5, 'Ground Truth plotting skipped (size mismatch or missing data).', 'HorizontalAlignment', 'center');
title('Ground Truth Label');
xlabel('Time (s)');
end

saveas(gcf, 'results/realtime_pipeline_output.png');
fprintf('Output plot saved to results/realtime_pipeline_output.png\n');

end
### END OF FILE: RunExoskeletonPipeline.m

### START OF FILE: TestPipelinePerformance.m
### FILE Path: scripts/TestPipelinePerformance.m
%% TestPipelinePerformance.m
% --------------------------------------------------------------------------
% FUNCTION: [metrics] = TestPipelinePerformance()
% PURPOSE: Runs the full real-time simulation pipeline and evaluates the 
% locomotion classification performance against ground truth labels.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-13
% LAST MODIFIED: 2025-12-13 (Fixed ground truth binarization and missing gyro data)
% --------------------------------------------------------------------------
% DEPENDENCIES: 
% - ExoConfig.m
% - ImportData.m
% - Features.m
% - RealtimeFsm.m
% - FusionKalman.m
% - Binary_SVM_Model.mat (Trained model)
% --------------------------------------------------------------------------
% NOTES:
% - Loads ground truth from Annotation.csv for the simulated activity.
% - Calculates Accuracy, Precision (Positive Predictive Value), and Recall (Sensitivity).
% --------------------------------------------------------------------------

function [metrics] = TestPipelinePerformance()

clc; close all;
cfg = ExoConfig();

% --- 0. Pre-Flight Check ---
model_path = cfg.FILE.SVM_MODEL;
if ~exist(model_path, 'file')
error('Trained SVM Model not found. Please run TrainSvmBinary first.');
end

% --- 1. Load Trained Model and Configuration ---
% Need to load ModelMetadata to ensure compatibility, even if not fully used here
loaded = load(model_path, 'SVMModel', 'ModelMetadata');
SVMModel = loaded.SVMModel;
ModelMetadata = loaded.ModelMetadata;

FS = ModelMetadata.fs;
WINDOW_SIZE = ModelMetadata.windowSize;
STEP_SIZE = ModelMetadata.stepSize;
ACTIVITY_NAME = cfg.ACTIVITY_SIMULATION;

fprintf('--- Starting Full Pipeline Performance Test ---\n');
fprintf('Simulating Activity: %s (FS: %d Hz)\n', ACTIVITY_NAME, FS);

% --- 2. Load Data and Ground Truth ---
try
[back, hipL, ~, annotations] = ImportData(ACTIVITY_NAME); 
n_total_samples = size(back.acc, 1);

if ~ismember('Label', annotations.Properties.VariableNames) || size(annotations, 1) ~= n_total_samples
error('Annotation file is invalid or size mismatch. Cannot perform evaluation.');
end

ground_truth = annotations.Label; % Multi-class label (e.g., 1, 4, 8)

% Fix: Binarize the ground truth label to match the FSM output (0 or 1)
walking_labels = cfg.DS.USCHAD.WALKING_LABELS; 
non_walking_labels = cfg.DS.USCHAD.NON_WALKING_LABELS; 

ground_truth_binary = zeros(size(ground_truth));
% Map locomotion labels to 1 (WALKING)
ground_truth_binary(ismember(ground_truth, walking_labels)) = cfg.STATE_WALKING; 
% Map non-locomotion labels to 0 (STANDING)
ground_truth_binary(ismember(ground_truth, non_walking_labels)) = cfg.STATE_STANDING; 

catch ME
error('Data loading or ground truth check failed: %s', ME.message);
end

% --- 3. Run Simulation (Simplified Pipeline Loop) ---

% Initialize states and filters
current_fsm_state = cfg.STATE_STANDING; 
fsm_plot = zeros(n_total_samples, 1);
last_command = 0;
% Filters are initialized in RunExoskeletonPipeline, but we initialize here too
[fuse_back, fuse_hipL] = initializeFilters(FS); 

for i = 1:n_total_samples

% Kinematics (Run but results discarded here, focus is on classification)
update(fuse_back, back.acc(i,:), back.gyro(i,:));
update(fuse_hipL, hipL.acc(i,:), hipL.gyro(i,:)); 

% Classification Check
if mod(i - 1, STEP_SIZE) == 0 && (i + WINDOW_SIZE - 1) <= n_total_samples

windowAcc = back.acc(i : i+WINDOW_SIZE-1, :);
windowGyro = back.gyro(i : i+WINDOW_SIZE-1, :); % Fix: Extract Gyro window

% Fix: Pass both Accel and Gyro to Features.m
features_vec = Features(windowAcc, windowGyro, FS); 
new_label = predict(SVMModel, features_vec); 

[exoskeleton_command, current_fsm_state] = RealtimeFsm(new_label, current_fsm_state);
last_command = exoskeleton_command; 
end

fsm_plot(i) = last_command;
end

% --- 4. Performance Evaluation ---

% We compare the FSM output (fsm_plot) against the binarized ground truth.
% True Positives (TP): Walk predicted as Walk
% Fix: Use ground_truth_binary instead of raw ground_truth
TP = sum(ground_truth_binary == 1 & fsm_plot == 1);
% True Negatives (TN): Stand predicted as Stand
TN = sum(ground_truth_binary == 0 & fsm_plot == 0);
% False Positives (FP): Stand predicted as Walk (Type I Error)
FP = sum(ground_truth_binary == 0 & fsm_plot == 1);
% False Negatives (FN): Walk predicted as Stand (Type II Error)
FN = sum(ground_truth_binary == 1 & fsm_plot == 0);

% Calculate Metrics
Accuracy = (TP + TN) / (TP + TN + FP + FN);
Precision = TP / (TP + FP); % How many predicted 'Walks' were correct
Recall = TP / (TP + FN); % How many actual 'Walks' were caught
Specificity = TN / (TN + FP); % How many actual 'Stands' were caught

metrics.TP = TP;
metrics.TN = TN;
metrics.FP = FP;
metrics.FN = FN;
metrics.Accuracy = Accuracy;
metrics.Precision = Precision;
metrics.Recall = Recall;
metrics.Specificity = Specificity;


% --- 5. Report Results ---
fprintf('\n--- Classification Performance Summary ---\n');
fprintf('Target Activity: %s\n', ACTIVITY_NAME);
fprintf('Total Samples: %d\n', n_total_samples);
fprintf('------------------------------------------\n');
fprintf('True Positives (TP): %d\n', TP);
fprintf('True Negatives (TN): %d\n', TN);
fprintf('False Positives (FP): %d\n', FP);
fprintf('False Negatives (FN): %d\n', FN);
fprintf('------------------------------------------\n');
fprintf('SYSTEM ACCURACY: %.2f%%\n', Accuracy * 100);
fprintf('PRECISION (Walk): %.2f%%\n', Precision * 100);
fprintf('RECALL (Walk): %.2f%%\n', Recall * 100);
fprintf('SPECIFICITY (Stand): %.2f%%\n', Specificity * 100);
fprintf('------------------------------------------\n');

end
### END OF FILE: TestPipelinePerformance.m

### START OF FILE: ConcatenateCode.m
### FILE Path: scripts/utils/ConcatenateCode.m
%% ConcatenateCode.m
% --------------------------------------------------------------------------
% FUNCTION: [] = ConcatenateCode()
% PURPOSE: Generates a single, structured file (concatenated_code.txt) 
%          containing the source code of the entire project.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-12
% LAST MODIFIED: 2025-12-13
% --------------------------------------------------------------------------
% DEPENDENCIES: 
%   - MATLAB built-in file I/O and utility functions.
% --------------------------------------------------------------------------
% NOTES:
%   - Uses '###' headers for visibility and structure.
%   - Output is saved to the directory from which the script is executed.
%   - Uses dynamic path resolution for cross-platform compatibility.
% --------------------------------------------------------------------------

root_directory = pwd; 
output_filename = 'concatenated_code.txt';
% The output path is now set to the current directory (where the script is run)
% and the output filename.
output_full_path = fullfile(root_directory, output_filename);

fprintf('Starting code concatenation for copying...\n');

% Dynamically extract the project name from the current working directory's parent
% This assumes the user is running the script from the 'utils' folder, 
% and the project root is the parent folder.
[parent_dir, project_name, ~] = fileparts(fileparts(root_directory));
% Handle cases where 'pwd' might be the project root itself for robustness
if isempty(project_name) || strcmpi(project_name, root_directory)
    [~, project_name, ~] = fileparts(root_directory);
end
% Ensure the project name is clean
project_name = strrep(project_name, filesep, '');

% 1. Find all .m files recursively and filter hidden folders
% Search from the PARENT directory to capture all project files
search_root = fileparts(root_directory); 
search_path = fullfile(search_root, '**', '*.m');
listing = dir(search_path);

files_to_concatenate = [];
for i = 1:length(listing)
    full_path = fullfile(listing(i).folder, listing(i).name);
    
    % Get the path relative to the true project root
    rel_path = extractAfter(full_path, search_root);
    if startsWith(rel_path, filesep)
        rel_path = extractAfter(rel_path, filesep);
    end
    
    % Check if any part of the path starts with a '.' (e.g., .git/...)
    parts = strsplit(rel_path, filesep);
    if ~any(startsWith(parts, '.'))
        files_to_concatenate = [files_to_concatenate; listing(i)];
    end
end

if isempty(files_to_concatenate)
    fprintf('No .m files found in visible project directories.\n');
    return;
end

% --- CUSTOM SORTING: Ensure correct file order (Root files first, then subfolders by path) ---
files_to_sort = files_to_concatenate; 
% 1. Calculate the relative path for every file
relative_paths = cell(length(files_to_sort), 1);
for i = 1:length(files_to_sort)
    full_path_abs = fullfile(files_to_sort(i).folder, files_to_sort(i).name);
    
    % Get the path relative to the true project root for sorting
    rel_path = extractAfter(full_path_abs, search_root);
    if startsWith(rel_path, filesep)
        rel_path = extractAfter(rel_path, filesep);
    end
    
    % Add a special prefix to root files to force them to sort first
    if isempty(fileparts(rel_path))
        relative_paths{i} = ['!', rel_path]; 
    else
        relative_paths{i} = rel_path;
    end
end
% 2. Sort the files based on the relative path strings
[~, idx] = sort(relative_paths);
files_to_concatenate = files_to_sort(idx);
% --------------------------------------------------------------------------------------------

% 2. Open the output file for writing (will overwrite if it exists)
fileID = fopen(output_full_path, 'wt', 'n', 'UTF-8');
if fileID == -1
    error('Could not open file for writing: %s', output_full_path);
end

% 3. Process and print/write each file
fprintf('\n--- CONCATENATED CODE START ---\n\n');
% Write the global header to the file (only to file)
fprintf(fileID, '--- CONCATENATED CODE FROM PROJECT: %s ---\n\n', project_name);

for i = 1:length(files_to_concatenate)
    file_info = files_to_concatenate(i);
    
    full_path_abs = fullfile(file_info.folder, file_info.name);
    
    % Construct the desired 'FILE Path' using the dynamic project name and relative segment
    rel_path_segment = extractAfter(full_path_abs, search_root);
    if startsWith(rel_path_segment, filesep)
        rel_path_segment = extractAfter(rel_path_segment, filesep);
    end
    
    % The output path format is now: ProjectName/relative/path/to/file.m
    file_path_output = sprintf('%s/%s', project_name, rel_path_segment);
    
    % Read the content of the file
    file_content = fileread(full_path_abs);
    
    % --- Generate Custom Structured Header (USING 3 HASH SIGNS) ---
    header_start_line1 = sprintf('### START OF FILE: %s\n', file_info.name);
    header_start_line2 = sprintf('### FILE Path: %s\n', file_path_output);
    header_end = sprintf('### END OF FILE: %s\n\n', file_info.name);
    
    % Print structured output to Command Window
    fprintf(header_start_line1);
    fprintf(header_start_line2);
    fprintf('%s\n', file_content); 
    fprintf(header_end);
    
    % Write structured output to the text file
    fprintf(fileID, header_start_line1);
    fprintf(fileID, header_start_line2);
    fprintf(fileID, '%s\n', file_content);
    fprintf(fileID, header_end);
end

% 4. Close the file and finalize output
fclose(fileID);
fprintf('\n--- CONCATENATED CODE END ---\n');
fprintf('Content printed to terminal for immediate copy/paste.\n');
fprintf('A consolidated version has also been saved to: %s\n', output_full_path);
### END OF FILE: ConcatenateCode.m

### START OF FILE: GenerateProjectTree.m
### FILE Path: scripts/utils/GenerateProjectTree.m
%% GenerateProjectTree.m
% --------------------------------------------------------------------------
% FUNCTION: [] = GenerateProjectTree()
% PURPOSE: Recursively scans the project directory and prints the folder/file structure to project_tree.txt.
% --------------------------------------------------------------------------
% DATE CREATED: 2025-12-12
% LAST MODIFIED: 2025-12-13
% --------------------------------------------------------------------------
% DEPENDENCIES: 
%   - MATLAB built-in functions (dir, fprintf, diary, fileparts)
% --------------------------------------------------------------------------
% NOTES:
%   - Excludes hidden folders (starting with '.').
%   - Truncates raw data folders with >200 files for readability.
%   - FIX: Script correctly determines the project root by traversing two 
%     levels up from the execution directory (e.g., .../scripts/utils/).
% --------------------------------------------------------------------------

% --- Define Paths ---
output_dir = pwd;                              % Location to save the output file (e.g., .../scripts/utils/)
output_filename = 'project_tree.txt';
output_full_path = fullfile(output_dir, output_filename); % Full path for the output file

% FIX: Project root is now two levels up from pwd
scripts_dir = fileparts(output_dir);           % Goes from 'utils' to 'scripts'
project_root = fileparts(scripts_dir);         % Goes from 'scripts' to 'AutomationForExoskeleton' (the true root)
% ---------------------

% Line 1: Output only to Command Window (pre-execution message)
fprintf('Starting project structure generation...\n');

% 0. EXPLICIT OVERWRITE FIX: Delete the output file if it exists to guarantee a clean overwrite.
if exist(output_full_path, 'file')
    delete(output_full_path);
end

% 1. Start capturing the Command Window output to the specified file
diary(output_full_path);

try
    % Lines that are saved to the file:

    % Display the root name followed by '/'.
    [~, root_name, ~] = fileparts(project_root); % Get the name of the true project root
    fprintf('%s/\n', root_name);

    % 2. Start the recursive drawing process
    drawTreeLevel(project_root, ''); % Start scanning from the true project root
    
catch ME
    % Ensure diary is turned off even if an error occurs
    diary off;
    
    % Display error message to the console
    warning('An error occurred during script execution. Diary was turned off.');
    rethrow(ME);
end

% 3. Stop capturing the Command Window output
diary off;

% Line 2: Output only to Command Window (post-execution success message)
fprintf('\nScan completed and saved to %s.\n', output_full_path);

%% --- NESTED FUNCTION (The Recursive Logic) ---

function drawTreeLevel(current_path, prefix)
% Recursively draws the content of the current folder.

% 1. Get all entries (files and folders) in the current directory
listing = dir(current_path);

% 2. Filter system entries ('.', '..')
is_valid_entry = ~ismember({listing.name}, {'.', '..'});
entries = listing(is_valid_entry);

% 3. Filter hidden directories (starting with '.')
is_not_hidden = ~startsWith({entries.name}, '.');
entries = entries(is_not_hidden);

% 4. Split into subfolders and files, sort alphabetically
folders = entries([entries.isdir]);
files = entries(~[entries.isdir]);

[~, folder_idx] = sort({folders.name});
folders = folders(folder_idx);

[~, file_idx] = sort({files.name});
files = files(file_idx);

sorted_entries = [folders; files];

if isempty(sorted_entries)
    return;
end

N = length(sorted_entries);

% 5. Iterate and draw each entry
for i = 1:N
    entry = sorted_entries(i);
    is_last = (i == N);
    
    % --- Determine Connectors and Next Prefix Segment ---
    if is_last
        connector = '└── ';
        new_prefix_segment = '    '; 
    else
        connector = '├── ';
        new_prefix_segment = '│   '; 
    end
    
    % Build the full line to print
    name_suffix = entry.name;
    if entry.isdir
        name_suffix = [name_suffix, '/'];
    end
    
    fprintf('%s%s%s\n', prefix, connector, name_suffix);
    
    % 6. If the entry is a folder, recurse into it
    if entry.isdir
        new_path = fullfile(current_path, entry.name);
        new_prefix = [prefix, new_prefix_segment];

        % Truncation check for massive raw data folders (over 200 files)
        sub_listing = dir(new_path);
        sub_entries_count = length(sub_listing(~ismember({sub_listing.name}, {'.', '..'})));
        
        if sub_entries_count > 200 && contains(entry.name, 'raw', 'IgnoreCase', true)
            fprintf('%s%s%s\n', new_prefix, '└── ', '... (truncated: many raw data files)');
        else
            drawTreeLevel(new_path, new_prefix);
        end
    end
end
end
### END OF FILE: GenerateProjectTree.m

